# Format String Vulnerability Writeup - PicoCTF Challenge

## Challenge Description

**Challenge Name:** Secret Menu (Format String)  
**Category:** Binary Exploitation  
**Description:** Patrick and SpongeBob were really happy with those orders you made for them, but now they're curious about the secret menu. Find it, and along the way, maybe you'll find something else of interest!

## Initial Analysis

The challenge provides a C program that demonstrates a classic format string vulnerability. Let's examine the source code to understand the vulnerability and develop an exploitation strategy.

### Source Code Analysis

```c
#include <stdio.h>

int main() {
    char buf[1024];
    char secret1[64];
    char flag[64];
    char secret2[64];

    // Read in first secret menu item
    FILE *fd = fopen("secret-menu-item-1.txt", "r");
    if (fd == NULL){
        printf("'secret-menu-item-1.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(secret1, 64, fd);
    
    // Read in the flag
    fd = fopen("flag.txt", "r");
    if (fd == NULL){
        printf("'flag.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(flag, 64, fd);
    
    // Read in second secret menu item
    fd = fopen("secret-menu-item-2.txt", "r");
    if (fd == NULL){
        printf("'secret-menu-item-2.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(secret2, 64, fd);

    printf("Give me your order and I'll read it back to you:\n");
    fflush(stdout);
    scanf("%1024s", buf);
    printf("Here's your order: ");
    printf(buf);  // <-- VULNERABILITY HERE
    printf("\n");
    fflush(stdout);

    printf("Bye!\n");
    fflush(stdout);

    return 0;
}
```

## Vulnerability Analysis

### Format String Vulnerability

The vulnerability exists in this line:
```c
printf(buf);
```

This is a classic format string vulnerability where user input is passed directly as the format string to `printf()`. When a user provides format specifiers (like `%p`, `%x`, `%s`) in their input, `printf()` will interpret them and potentially leak memory contents or allow memory manipulation.

### Memory Layout

The program declares four local variables in `main()`:
- `char buf[1024]` - stores user input
- `char secret1[64]` - contains first secret menu item
- `char flag[64]` - **contains the flag we want to extract**
- `char secret2[64]` - contains second secret menu item

These variables are allocated on the stack, and their contents (including the flag) will be present in memory during execution.

### Safe Input Handling

Note that the program uses `scanf("%1024s", buf)`, which limits input to 1023 characters plus null terminator. This prevents buffer overflow attacks against the `buf` array itself, but doesn't protect against the format string vulnerability.

## Exploitation Strategy

### Step 1: Stack Reconnaissance

To exploit this vulnerability, we need to determine where on the stack our target data (the flag) is located. We can use pointer format specifiers (`%p`) to dump stack contents.

**Payload:** `%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p`

This payload uses multiple `%p` specifiers separated by commas to make the output more readable. Each `%p` will print a pointer value from the stack.

### Step 2: Analyzing the Output

When we run our payload, we get output containing hexadecimal values from the stack. The key is to identify which values correspond to our flag data.

![Stack dump output showing hexadecimal values](https://github.com/user-attachments/assets/4528965d-629e-4729-8ebd-95a160b11fdc)

### Step 3: Converting Hexadecimal to ASCII

The flag data appears as hexadecimal values on the stack. We need to convert these hex values back to ASCII characters. There are several ways to do this:

#### Method 1: Using CyberChef
1. Copy the hexadecimal values
2. Use CyberChef's "From Hex" operation
3. Convert the output to readable text

![CyberChef hex to ASCII conversion](https://github.com/user-attachments/assets/b9b40b5d-5e45-4017-9ffd-d8f1ece6fa65)

We got result:
```
{FTCocip5_14m1n44x4_31y746_g41f_}611772wu.Ñc..0...r.æ.7C.%
3lytS	
```

The order needs to be rearranged - reverse each hex-decoded chunk (from stack, remember it's top-down in memory).

#### Method 2: Using Command Line Tools
```bash
echo 'hex_value' | xxd -r -p | rev
```

![Alternative approach using command line tools](https://github.com/user-attachments/assets/9c8c11e7-d0dc-4a35-9696-48369fddaef8)

Where:
- `xxd -r -p` converts hex back to binary
  - `xxd` is a hex dump tool
  - `-r` tells it to reverse a hex dump back into binary
  - `-p` (plain) means the input is a continuous stream of hex digits without addresses or formatting
- `rev` reverses the string (important due to little-endian byte ordering)

### Step 4: Reconstructing the Flag

Due to how data is stored on the stack (little-endian format), we need to:
1. Extract the relevant hexadecimal values
2. Convert each hex chunk to ASCII
3. Reverse each chunk to account for endianness
4. Concatenate the results in the correct order

## Solution

### Exploitation Process

1. **Input payload:** `%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p`

2. **Extract hex values from output:** Look for patterns that correspond to printable ASCII characters

3. **Convert and reconstruct:** 
   - Identify hex values that contain flag data
   - Convert each value from hex to ASCII
   - Reverse each chunk due to little-endian storage
   - Assemble the complete flag

### Final Flag

After processing the hex values and reconstructing the string:

**Flag:** `picoCTF{4n1m41_57y13_4x4_f14g_64277116}`

## Prevention Measures

### Secure Coding Practices

To prevent format string vulnerabilities:

1. **Never use user input directly as format strings:**
   ```c
   // Vulnerable
   printf(user_input);
   
   // Secure
   printf("%s", user_input);
   ```

2. **Use compiler warnings:** Enable format string security warnings (`-Wformat-security`)

3. **Input validation:** Sanitize user input to remove format specifiers

4. **Use safer alternatives:** Consider using functions like `puts()` for simple string output

### Compiler Protections

Modern compilers and systems include protections against format string attacks:
- Stack canaries
- Address Space Layout Randomization (ASLR)
- Format string protection flags

## Key Takeaways

1. **Format string vulnerabilities** occur when user-controlled data is used as a format string in functions like `printf()`
2. **Stack data exposure** allows attackers to read sensitive information from memory
3. **Endianness matters** when converting hex values back to readable strings
4. **Prevention is straightforward** but requires awareness and proper coding practices

This challenge demonstrates the importance of secure coding practices and the potential impact of seemingly small vulnerabilities in real-world applications.
