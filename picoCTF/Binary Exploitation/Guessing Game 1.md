# Guessing Game 1 – Writeup

**Author:** madStacks
**Category:** Binary Exploitation / Reverse Engineering

---

## 🧩 Challenge Description

> “I made a simple game to show off my programming skills. See if you can beat it!”
> We are given a binary named `guessing_game`. The goal is to find the flag by analyzing and exploiting the program.

---

## 🔍 Step 1: Initial Analysis

We start by checking the file type:

```bash
file guessing_game
```

It’s a 64-bit ELF binary, dynamically linked, and not stripped. This means we can see function names in Ghidra or IDA.

Next, we run the binary:

```bash
./guessing_game
```

The program asks for a number — it’s a guessing game.

---

## 🧠 Step 2: Reverse Engineering

We open it in **Ghidra** or **IDA** and find a main function similar to this pseudocode:

```c
int main() {
    int number;
    srand(time(0));
    int target = rand() % 100;
    printf("Guess a number: ");
    scanf("%d", &number);
    if (number == target) {
        printf("You win! Here's your flag:\n");
        system("cat flag.txt");
    } else {
        printf("Wrong guess! Try again.\n");
    }
    return 0;
}
```

So, the flag is printed only when our guess matches the random number.

---

## 🧪 Step 3: Finding the Random Value

The target number is generated using `rand()` seeded by `time(0)`. Since `time(0)` changes every second, we can predict it if we run the program quickly after analyzing.

We can brute-force possible seeds to get the same output. Example script:

```python
from pwn import *
from time import time

elf = context.binary = ELF('./guessing_game')

for t in range(int(time()) - 5, int(time()) + 5):
    random = (t * 1103515245 + 12345) & 0x7fffffff
    guess = random % 100
    io = process('./guessing_game')
    io.sendline(str(guess))
    res = io.recvall().decode()
    if 'flag' in res:
        print(res)
        break
```

Alternatively, we can patch the binary to always win.

---

## 🧰 Step 4: Binary Patching (Optional)

In Ghidra, we can modify the comparison instruction:

```
if (number == target)
```

Change the `jne` (jump not equal) instruction to `jmp` — this forces the win condition.

Use a hex editor or `pwntools` patching:

```python
from pwn import *
elf = ELF('./guessing_game')
elf.asm(0x40123a, 'jmp 0x401245')  # Skip the failure branch
elf.save('./patched')
```

Run it:

```bash
./patched
Guess a number: 1
You win! Here's your flag:
flag{example_flag_here}
```

---

## 🎯 Step 5: Conclusion

We learned that the game uses predictable random numbers. By controlling or patching the logic, we can force the program to reveal the flag.

**Flag:** `flag{example_flag_here}`
