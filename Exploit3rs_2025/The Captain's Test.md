# The Captain's Test - CTF Writeup

**Challenge Name:** The Captain's Test  
**Category:** Reverse Engineering  
**Points:** 150  
**Flag:** `Exploit3rs{quick_draw_master}`

---

## Challenge Description

> The ship is on the brink of disaster, and the Captain is counting on you to prove you have what it takes to save it. Deep within the shadows of his quarters, he's concealed a secret code locked inside an ancient executable file. Unlock it, and you'll earn his trust—and the fate of the ship will rest in your hands.

We are provided with a single binary file called `QuickDraw`.

---

## Initial Reconnaissance

### File Analysis

First, let's identify what type of file we're dealing with:
```bash
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ file QuickDraw 
QuickDraw: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=979c889cc9ca56a33ed67aeb4d2d05cb8db2df1b, 
for GNU/Linux 2.6.32, stripped
```

**Key Observations:**
- **ELF 64-bit**: Linux executable format
- **x86-64**: Standard Intel/AMD architecture
- **Dynamically linked**: Uses shared system libraries
- **Stripped**: Debug symbols removed (function names are gone)

### Security Protections

Let's check what security mechanisms are in place:
```bash
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ checksec --file=QuickDraw 
RELRO           STACK CANARY      NX            PIE             
Partial RELRO   No canary found   NX enabled    No PIE
```

**Security Features:**
- **No Stack Canary**: Vulnerable to buffer overflows
- **NX Enabled**: Stack is not executable
- **No PIE**: Loads at fixed memory address

For this challenge, these protections aren't critical since we'll be doing static analysis.

---

## Finding the Golden Thread

### String Analysis

One of the most powerful initial reconnaissance techniques is examining strings within the binary:
```bash
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ strings QuickDraw | grep -i python
Error loading Python lib '%s': dlopen: %s
Failed to pre-initialize embedded python interpreter!
Failed to allocate PyConfig structure! Unsupported python version?
Failed to set python home path!
Failed to start embedded python interpreter!
libpython3.11.so.1.0
```

**Critical Discovery:** The binary contains Python-related strings! This suggests the executable might be a packaged Python application.

Let's search for PyInstaller signatures:
```bash
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ strings QuickDraw | grep -i "pyi"
pyi-contents-directory
pyi-runtime-tmpdir
_PYI_ONEDIR_MODE
_PYI_PROCNAME
Cannot open PyInstaller archive from executable (%s) or external archive (%s)
pyiboot01_bootstrap
pyimod01_archive
pyimod02_importers
pyi_rth_inspect
```

**Eureka Moment:** Multiple PyInstaller-specific strings confirm this is a PyInstaller-packed executable!

### What is PyInstaller?

PyInstaller is a tool that converts Python scripts into standalone executables. It packages:
- Your Python script
- Python interpreter
- Required libraries
- All dependencies

Into a single executable that runs without needing Python installed.

**Why This Matters for CTFs:**
```
Normal Compiled Binary (C/C++):
    Source Code → Compiler → Machine Code
    ❌ Original source code is lost
    ❌ Extremely difficult to reverse
    
PyInstaller Binary:
    Python Script → PyInstaller → Executable
    ✅ Original Python code is INSIDE (as bytecode)
    ✅ Can be extracted and decompiled
    ✅ Much easier to reverse!
```

---

## Decompiled Code Analysis

Using Ghidra or similar tools, we can see the PyInstaller bootloader code. Key indicators include:
```c
__s2 = (char *)FUN_00407950("_MEIPASS2");  // PyInstaller temp directory
```
```c
"Cannot open PyInstaller archive from executable (%s) or external archive (%s)\n"
```
```c
auStack_2048[0] = 0xe0b0a0b0d49454d;  // Magic bytes: "MEI" (PyInstaller signature)
```

These confirm we're dealing with PyInstaller's bootloader wrapper.

---

## Extraction Phase

### Using pyinstxtractor

The standard tool for extracting PyInstaller archives is `pyinstxtractor.py`:
```bash
# Download the extraction tool
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ wget https://raw.githubusercontent.com/extremecoders-re/pyinstxtractor/master/pyinstxtractor.py

# Extract the PyInstaller archive
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ python3 pyinstxtractor.py QuickDraw
[+] Processing QuickDraw
[+] Pyinstaller version: 2.1+
[+] Python version: 3.11
[+] Length of package: 7541334 bytes
[+] Found 31 files in CArchive
[+] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap.pyc
[+] Possible entry point: pyi_rth_inspect.pyc
[+] Possible entry point: QuickDraw.pyc
[!] Warning: This script is running in a different Python version than the one used to build the executable.
[!] Please run this script in Python 3.11 to prevent extraction errors during unmarshalling
[!] Skipping pyz extraction
[+] Successfully extracted pyinstaller archive: QuickDraw
```

**Key Information:**
- **Python version: 3.11** - Important for decompilation compatibility
- **31 files extracted** - Includes Python interpreter, libraries, and our target
- **Entry point: QuickDraw.pyc** - This is our main challenge file!

### Examining Extracted Files
```bash
┌──(xuan㉿kali)-[~/challenge_contents]
└─$ cd QuickDraw_extracted

┌──(xuan㉿kali)-[~/challenge_contents/QuickDraw_extracted]
└─$ ls -la
total 17180
drwxrwxr-x 4 xuan xuan    4096 Nov  1 14:20 .
drwxrwxr-x 3 xuan xuan    4096 Nov  1 14:20 ..
-rw-rw-r-- 1 xuan xuan 1322660 Nov  1 14:20 PYZ-00.pyz
drwxrwxr-x 2 xuan xuan    4096 Nov  1 14:20 PYZ-00.pyz_extracted
-rw-rw-r-- 1 xuan xuan    1161 Nov  1 14:20 QuickDraw.pyc          ← TARGET!
-rw-rw-r-- 1 xuan xuan 1443550 Nov  1 14:20 base_library.zip
drwxrwxr-x 2 xuan xuan    4096 Nov  1 14:20 lib-dynload
-rw-rw-r-- 1 xuan xuan 7675744 Nov  1 14:20 libpython3.11.so.1.0
-rw-rw-r-- 1 xuan xuan    1695 Nov  1 14:20 pyi_rth_inspect.pyc
-rw-rw-r-- 1 xuan xuan    1854 Nov  1 14:20 pyiboot01_bootstrap.pyc
```

**File Breakdown:**
- **QuickDraw.pyc** - The actual challenge code (our target!)
- **PYZ-00.pyz** - Compressed Python standard library archive
- **libpython3.11.so.1.0** - Python 3.11 interpreter
- **pyiboot01_bootstrap.pyc** - PyInstaller's startup code
- Other files are supporting libraries

---

## Decompilation Phase

### Understanding .pyc Files

A `.pyc` file is Python bytecode - an intermediate compiled format:
```
.py (Source Code)          →  .pyc (Bytecode)
def hello():                   LOAD_GLOBAL (print)
    print("Hello")             LOAD_CONST ('Hello')
                               CALL_FUNCTION
                               RETURN_VALUE
```

**Structure of a .pyc file:**
```
┌─────────────────────────┐
│  Magic Number (4 bytes) │  ← Python version identifier
│  Timestamp (4 bytes)    │  ← Compilation time
│  Size (4 bytes)         │  ← Source size
│  Hash (8 bytes)         │  ← Python 3.11+ checksum
├─────────────────────────┤
│  Code Object            │  ← THE ACTUAL CODE!
│  - Bytecode instructions│
│  - String constants     │  ← Flag might be here!
│  - Variable names       │
│  - Function definitions │
└─────────────────────────┘
```

### Decompilation Attempts

First, let's try the popular `uncompyle6`:
```bash
┌──(xuan㉿kali)-[~/challenge_contents/QuickDraw_extracted]
└─$ python3 -m venv venv
└─$ source venv/bin/activate
└─$ pip3 install uncompyle6
└─$ uncompyle6 QuickDraw.pyc > QuickDraw.py

# Unsupported bytecode in file QuickDraw.pyc
# Unsupported Python version, 3.11, for decompilation
```

**Problem:** `uncompyle6` doesn't support Python 3.11!

### Alternative Approach: pycdc

For Python 3.11+, we need to use `pycdc`:
```bash
# Install pycdc
cd ~
git clone https://github.com/zrax/pycdc.git
cd pycdc
cmake .
make

# Decompile with pycdc
~/pycdc/pycdc ~/challenge_contents/QuickDraw_extracted/QuickDraw.pyc
```

### Quick Win: String Search

Sometimes the easiest approach works best:
```bash
┌──(xuan㉿kali)-[~/challenge_contents/QuickDraw_extracted]
└─$ strings QuickDraw.pyc
check_speed
My only condition to join the crew is to shoot as fast as we do - A fraction of a second is all it takes -
Get ready... Type 'shoot' as fast as you can when prompted!
Type 'shoot' NOW: 
shoot
Congratulations! You've earned the flag: 
Exploit3rs{quick_draw_master}
Too slow! You took 
.3f
 seconds. Try again!
```

**Jackpot!** The flag is visible in the strings output!

---

## Understanding the Challenge Logic

After decompilation (or careful analysis of strings), we can reconstruct the challenge:
```python
import time

def check_speed():
    print('My only condition to join the crew is to shoot as fast as we do - A fraction of a second is all it takes -\n')
    print("Get ready... Type 'shoot' as fast as you can when prompted!\n")
    
    start = time.time()
    user_input = input("Type 'shoot' NOW: ")
    end = time.time()
    time_taken = end - start
    
    if user_input.lower() == 'shoot' and time_taken < 0.1:
        print("Congratulations! You've earned the flag: \x13Exploit3rs{quick_draw_master}")
        return None
    None(f'''Too slow! You took {time_taken:.3f} seconds. Try again!''')

check_speed()
```

### Challenge Analysis

**The Challenge:**
- User must type "shoot" in less than **0.1 seconds (100 milliseconds)**
- This is physically impossible for humans!

**The Lesson:**
- Some challenges aren't meant to be "won" by playing
- Static analysis (reverse engineering) is the intended solution
- The flag is embedded in the code itself

**Alternative Dynamic Approaches (if static analysis failed):**
```python
# Approach 1: Patch the time check
import time
time.time = lambda: 0  # Always return 0

# Approach 2: Use pwntools for instant input
from pwn import *
p = process('./QuickDraw')
p.sendline(b'shoot')

# Approach 3: Modify the .pyc bytecode to skip the time check
```

---

## Solution Summary

### Step-by-Step Solution

1. **Reconnaissance**
```bash
   file QuickDraw
   checksec --file=QuickDraw
   strings QuickDraw | grep -i python
   strings QuickDraw | grep -i pyi
```

2. **Identify PyInstaller**
   - Found Python 3.11 references
   - Discovered PyInstaller signatures
   - Confirmed packaged Python application

3. **Extract Archive**
```bash
   wget https://raw.githubusercontent.com/extremecoders-re/pyinstxtractor/master/pyinstxtractor.py
   python3 pyinstxtractor.py QuickDraw
```

4. **Analyze Bytecode**
```bash
   cd QuickDraw_extracted
   strings QuickDraw.pyc | grep -E "flag|Exploit3rs"
```

5. **Retrieve Flag**
   - Flag found in string constants: `Exploit3rs{quick_draw_master}`

---

## Key Takeaways

### Technical Skills Learned

1. **PyInstaller Recognition**
   - Identifying packed Python executables
   - Understanding bootloader signatures
   - Magic bytes: `0xe0b0a0b0d49454d` = "MEI"

2. **Python Bytecode Analysis**
   - Understanding .pyc file structure
   - Difference between source code and bytecode
   - Decompilation tool selection based on Python version

3. **Static vs Dynamic Analysis**
   - Sometimes the challenge is impossible to "solve" normally
   - Static analysis can reveal hidden information
   - String analysis is often the quickest path

### Tools Used

- `file` - File type identification
- `checksec` - Binary security analysis
- `strings` - Extract printable strings
- `pyinstxtractor.py` - PyInstaller archive extraction
- `uncompyle6` / `pycdc` - Python bytecode decompilers
- `Ghidra` - Binary decompilation (optional)

### CTF Patterns

1. **Impossible Challenges** - If a challenge seems physically impossible, static analysis is likely the answer
2. **Low-Hanging Fruit** - Always try `strings` first - flags are often hardcoded
3. **Python Packaging** - PyInstaller binaries are common in CTFs and much easier to reverse than compiled C/C++
4. **Version Compatibility** - Always check Python versions when decompiling bytecode

---

## Flag
```
Exploit3rs{quick_draw_master}
```

---

## References

- [PyInstaller Documentation](https://pyinstaller.org/)
- [pyinstxtractor GitHub](https://github.com/extremecoders-re/pyinstxtractor)
- [pycdc - Python Bytecode Decompiler](https://github.com/zrax/pycdc)
- [Python Bytecode Structure](https://docs.python.org/3/library/dis.html)

---
