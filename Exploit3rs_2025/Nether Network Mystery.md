# Nether Network Mystery - CTF Writeup

**Challenge Name:** Nether Network Mystery  
**Points:** 350  
**Category:** Reverse Engineering / Firmware Analysis  
**Flag Format:** `Exploit3rs{HashValue}`

---

## Challenge Description

The villagers are suspicious of two server maintenance teams, the Redstone Engineers and the Iron Golems. While the Redstone Engineers' data logs seem incomplete, Pete confirms they are more trustworthy than the Iron Golems. However, their report lacks vital licensing details and crucial hashes for key files. 

**Your task:** Analyze the firmware and extract the SHA256 hash of the netdata executable powering the router.

**Given File:** `blockshire_router_firmware.bin`

---

## Table of Contents

1. [Understanding the Basics](#understanding-the-basics)
2. [Phase 1: File Identification](#phase-1-file-identification)
3. [Phase 2: Extracting the TAR Archive](#phase-2-extracting-the-tar-archive)
4. [Phase 3: Understanding Filesystem Structure](#phase-3-understanding-filesystem-structure)
5. [Phase 4: Extracting SquashFS](#phase-4-extracting-squashfs)
6. [Phase 5: Finding the Target](#phase-5-finding-the-target)
7. [Phase 6: Calculating SHA256 Hash](#phase-6-calculating-sha256-hash)
8. [Solution Summary](#solution-summary)
9. [Key Takeaways](#key-takeaways)

---

## Understanding the Basics

### What is Firmware?

**Firmware** is software that's embedded into hardware devices like:
- Routers
- IoT devices
- Cameras
- Smart appliances
- Embedded systems

Think of it as the "operating system" for hardware devices. While your computer runs Windows/Linux, a router runs **firmware** (which is typically a tiny, specialized Linux distribution).

### What is a Firmware Image?

When manufacturers create firmware, they package everything into a single file called a **firmware image** or **firmware binary**. This file contains:

- **The kernel** - Core operating system
- **The filesystem** - All files, programs, and configurations
- **Boot loader** - Instructions for starting the device
- **System components** - Drivers, libraries, utilities

In this challenge, `blockshire_router_firmware.bin` is that firmware image.

### What is netdata?

**netdata** is a real-time system monitoring tool that tracks:
- CPU usage
- RAM usage
- Network traffic
- Disk I/O
- System performance metrics

**Why is it on a router?**
- Routers need to monitor their performance (bandwidth, connections, uptime)
- netdata provides a web dashboard for administrators
- Helps detect issues like network congestion or hardware failures

---

## Phase 1: File Identification

### Step 1.1: Attempting to Execute the File

First, let's try to run the file:

```bash
chmod +x blockshire_router_firmware.bin
./blockshire_router_firmware.bin
```

**Output:**
```
zsh: exec format error: ./blockshire_router_firmware.bin
```

### Why Did This Fail?

1. **It's not an executable program** - It's a *container* that holds many files
2. **Wrong architecture** - Routers use ARM/MIPS processors, not x86/x64
3. **It's a package format** - Like a ZIP file, not a standalone program

### Step 1.2: Using the `file` Command

The `file` command is your first tool in any binary analysis:

```bash
file blockshire_router_firmware.bin
```

**Output:**
```
blockshire_router_firmware.bin: POSIX tar archive (GNU)
```

**What does `file` do?**
- Reads the first few bytes of a file (called "magic bytes" or file signature)
- Identifies what type of file it is based on these signatures
- Doesn't rely on file extensions (`.bin` can be anything!)

**What is a TAR archive?**
- **TAR** = **T**ape **AR**chive (old Unix format for backups)
- Like a ZIP file but without compression
- Bundles multiple files/folders into one file
- Commonly used in Linux/Unix systems

### Step 1.3: Why checksec Failed

```bash
checksec --file=blockshire_router_firmware.bin
```

**Output:**
```
Error: Not an ELF file
```

`checksec` only works on **ELF** (Executable and Linkable Format) files - compiled Linux programs. Our TAR archive is not an ELF file, so this tool doesn't apply here.

---

## Phase 2: Extracting the TAR Archive

### Step 2.1: Creating a Working Directory

```bash
mkdir firmware_extracted
tar -xvf blockshire_router_firmware.bin -C firmware_extracted/
```

**Command Breakdown:**
- `tar` - The program that handles TAR archives
- `-x` - **E**xtract (unpack the archive)
- `-v` - **V**erbose (show what's being extracted)
- `-f` - **F**ile (specify which file to extract)
- `blockshire_router_firmware.bin` - The file we're extracting
- `-C firmware_extracted/` - **C**hange directory (extract into this folder)

**Output:**
```
sysupgrade-meraki_mr32/
sysupgrade-meraki_mr32/CONTROL
sysupgrade-meraki_mr32/kernel
sysupgrade-meraki_mr32/root
```

### Step 2.2: Exploring the Extracted Contents

```bash
cd firmware_extracted/
ls -la
```

We get a directory `sysupgrade-meraki_mr32` with three files inside.

---

## Phase 3: Understanding Filesystem Structure

### Step 3.1: Identifying Each File

```bash
cd sysupgrade-meraki_mr32/
file *
```

**Output:**
```
CONTROL: BOA archive data
kernel:  Device Tree Blob version 17, size=2640268, boot CPU=0, ...
root:    Squashfs filesystem, little endian, version 4.0, xz compressed, ...
```

### Understanding Each File:

#### 1. CONTROL - BOA Archive Data
- Contains **metadata** about the firmware
- Version information, checksums, build details
- Not important for finding the netdata executable

#### 2. kernel - Device Tree Blob
- This is the **Linux kernel** (the core of the operating system)
- "Device Tree Blob" describes the hardware layout
- Think of it as the "brain" of the firmware
- Not what we need (we need the filesystem with programs)

#### 3. root - SquashFS Filesystem ‚≠ê **THIS IS WHAT WE NEED**
- Contains **all the files and programs** of the router
- Like the C:\ drive on Windows or / on Linux
- This is where the `netdata` executable will be located

### Step 3.2: Understanding SquashFS

**What is SquashFS?**
- **Squash** = compress/flatten
- **FS** = **F**ile**S**ystem
- A **compressed, read-only** filesystem

**Why use SquashFS for routers?**

1. **Space efficient** - Routers have limited storage (8MB-128MB typically)
2. **Read-only** - Prevents malware from modifying core system files
3. **Fast boot** - Compressed = smaller size = faster to load into memory
4. **Reliable** - Less prone to corruption since it's read-only

**Real-world analogy:**
- Normal filesystem (ext4, NTFS) = A filing cabinet where you can add/remove/modify folders
- SquashFS = A sealed **textbook** - you can read it but not change the printed pages

### Step 3.3: Using binwalk for Analysis

```bash
binwalk root
```

**Output:**
```
DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             Squashfs filesystem, little endian, version 4.0, 
                              compression:xz, size: 11550948 bytes, 1199 inodes, 
                              blocksize: 262144 bytes, created: 2023-01-31 15:36:57
```

**What is binwalk?**
- A tool that scans files for **embedded** files/filesystems
- "Walks" through the binary looking for magic bytes (file signatures)
- Essential for firmware analysis

**Understanding the Output:**

- **DECIMAL 0 / HEX 0x0** - The filesystem starts at byte 0 (beginning of file)
- **Squashfs filesystem** - Confirms it's SquashFS format
- **little endian** - Byte ordering (how numbers are stored in memory)
- **version 4.0** - SquashFS version
- **compression: xz** - Uses XZ compression algorithm (high compression ratio)
- **size: 11550948 bytes** - ~11.5 MB
- **1199 inodes** - 1199 filesystem objects (files, directories, links)

---

## Phase 4: Extracting SquashFS

### Step 4.1: Using unsquashfs

```bash
mkdir squashfs-root
unsquashfs -d squashfs-root root
```

**Command Breakdown:**
- `unsquashfs` - Tool to extract SquashFS filesystems
- `-d squashfs-root` - **D**estination folder name
- `root` - The SquashFS file to extract

**Output:**
```
Parallel unsquashfs: Using 15 processors
1076 inodes (981 blocks) to write

create_inode: could not create character device squashfs-root/dev/console, 
because you're not superuser!

created 883 files
created 123 directories
created 192 symlinks
created 0 devices
created 0 fifos
created 0 sockets
created 0 hardlinks
```

**Understanding the Output:**

- **1076 inodes** - Individual filesystem objects
- **981 blocks** - Chunks of data on disk
- **883 files** - Regular files extracted
- **123 directories** - Folders created
- **192 symlinks** - Symbolic links (shortcuts to other files)
- **Warning about devices** - Normal! Device files require root privileges

### Step 4.2: Alternative Extraction with binwalk

```bash
binwalk -e root
```

This also works, but `unsquashfs` is more reliable for SquashFS filesystems. The `-e` flag tells binwalk to extract any filesystems it finds.

### Step 4.3: Understanding the Directory Structure

After extraction, you now have access to the entire router's filesystem:

```
squashfs-root/
‚îú‚îÄ‚îÄ bin/          # Essential user binaries (ls, cat, cp, etc.)
‚îú‚îÄ‚îÄ sbin/         # System binaries (requiring root)
‚îú‚îÄ‚îÄ etc/          # Configuration files
‚îú‚îÄ‚îÄ lib/          # System libraries
‚îú‚îÄ‚îÄ usr/
‚îÇ   ‚îú‚îÄ‚îÄ bin/      # User programs
‚îÇ   ‚îú‚îÄ‚îÄ sbin/     # System administration programs ‚≠ê
‚îÇ   ‚îú‚îÄ‚îÄ lib/      # Additional libraries
‚îÇ   ‚îî‚îÄ‚îÄ share/    # Shared data files
‚îú‚îÄ‚îÄ var/          # Variable data (logs, temp files)
‚îî‚îÄ‚îÄ ... (other directories)
```

### Important: Why Can't You `cd` into `root`?

```bash
cd root  # ‚ùå ERROR: cd: not a directory: root
```

**Why does this fail?**

The `root` file is a **FILE**, not a **DIRECTORY**!

- `root` = A **SquashFS filesystem image** (like a .iso or .zip file)
- It's a single file that *contains* a filesystem inside
- You cannot `cd` into a file - you can only `cd` into directories

**Correct way:**
```bash
cd squashfs-root/  # ‚úÖ CORRECT - This is the extracted directory
```

**Analogy:**
- `root` = A sealed box (file)
- `squashfs-root/` = The contents after opening the box (directory)

---

## Phase 5: Finding the Target

### Step 5.1: Searching for netdata Files

```bash
find squashfs-root -type f -iname "*netdata*"
```

**Command Breakdown:**
- `find` - Search for files/directories
- `squashfs-root` - Where to search (the directory)
- `-type f` - Only find **f**iles (not directories)
- `-iname "*netdata*"` - **I**nsensitive **name** match with wildcards
  - `*` = Match any characters before/after
  - `netdata` = The string we're looking for
  - `-iname` = Case-insensitive (matches "Netdata", "NETDATA", "netdata")

**Output:**
```
squashfs-root/etc/init.d/netdata               # Startup script
squashfs-root/etc/netdata/netdata.conf         # Configuration file
squashfs-root/lib/upgrade/keep.d/netdata       # Upgrade metadata
squashfs-root/usr/sbin/netdata                 # ‚≠ê THE EXECUTABLE!
squashfs-root/usr/lib/netdata/...              # Libraries
squashfs-root/usr/share/netdata/...            # Web dashboard files
```

### Step 5.2: Identifying the Correct File

**How do we know `usr/sbin/netdata` is the executable?**

**Linux/Unix Filesystem Hierarchy Standard:**

| Directory | Purpose | Examples |
|-----------|---------|----------|
| `/bin/` | Essential user binaries | ls, cat, cp, bash |
| `/sbin/` | System binaries (root) | init, reboot, fsck |
| `/usr/bin/` | User programs | firefox, vim, git |
| `/usr/sbin/` | System admin programs ‚≠ê | apache2, sshd, **netdata** |
| `/etc/` | Configuration files | netdata.conf, passwd |
| `/lib/` | System libraries | *.so files |
| `/usr/share/` | Shared data | docs, images, web files |

**Key indicators:**
- `/usr/sbin/` - Standard location for system service executables
- Single file named `netdata` (not `netdata.conf` or `netdata.js`)
- No file extension (Linux executables don't need .exe)

### Step 5.3: Verifying It's an Executable

```bash
file squashfs-root/usr/sbin/netdata
```

**Expected output:**
```
squashfs-root/usr/sbin/netdata: ELF 32-bit LSB executable, ARM, 
EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-armhf.so.1, 
stripped
```

**Understanding the Output:**

- **ELF** - **E**xecutable and **L**inkable **F**ormat (Linux executable format)
- **32-bit** - 32-bit architecture (not 64-bit)
- **LSB** - **L**east **S**ignificant **B**yte first (endianness/byte order)
- **ARM** - Processor architecture (not x86/x64)
- **EABI5** - Embedded Application Binary Interface version 5
- **dynamically linked** - Uses shared libraries (not standalone)
- **stripped** - Debug symbols removed (smaller size, harder to reverse)

**This confirms it's a compiled executable program!**

### Why ARM Architecture?

**Why do routers use ARM instead of x86?**

1. **Power efficiency** - ARM uses less power (important for always-on devices)
2. **Lower cost** - ARM chips are cheaper to manufacture
3. **Smaller size** - Physically smaller chips
4. **Heat** - Generates less heat (often no fan needed)
5. **Sufficient performance** - Routers don't need desktop CPU power

**Common architectures in embedded devices:**
- **ARM** - Most routers, smartphones, IoT devices (80%+ market share)
- **MIPS** - Older routers, some embedded systems
- **PowerPC** - Some network equipment
- **x86/x64** - Rare in embedded (too power-hungry and expensive)

---

## Phase 6: Calculating SHA256 Hash

### Step 6.1: Using sha256sum

```bash
sha256sum squashfs-root/usr/sbin/netdata
```

**Output:**
```
1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11  squashfs-root/usr/sbin/netdata
```

### Understanding SHA256 Hash

**What is SHA256?**

- **SHA** = **S**ecure **H**ash **A**lgorithm
- **256** = Produces a 256-bit (32-byte) hash
- Developed by NSA in 2001
- Part of the SHA-2 family (SHA-224, SHA-256, SHA-384, SHA-512)

**What is a hash function?**

A **one-way mathematical function** that:
1. Takes any input (file, text, data)
2. Produces a fixed-length output (hash/digest)
3. Cannot be reversed (one-way function)

**Properties of SHA256:**

1. **Deterministic** - Same input always produces same hash
   ```
   File A ‚Üí SHA256 ‚Üí abc123...  (always the same)
   ```

2. **Unique** - Different inputs produce different hashes
   ```
   File A ‚Üí SHA256 ‚Üí abc123...
   File B ‚Üí SHA256 ‚Üí def456...  (completely different)
   ```

3. **One-way** - Cannot reverse hash back to original
   ```
   abc123... ‚Üí ??? ‚Üí Cannot recover File A
   ```

4. **Avalanche effect** - Tiny change = completely different hash
   ```
   "hello"  ‚Üí SHA256 ‚Üí 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   "hellp"  ‚Üí SHA256 ‚Üí 4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a
   (Only 1 character different, but completely different hash!)
   ```

5. **Fixed length** - Always 64 hexadecimal characters (256 bits)
   ```
   Small file:  ‚Üí 64 hex chars
   1GB file:    ‚Üí 64 hex chars (same length!)
   ```

### Why Use Hashes in Security?

#### 1. File Integrity Verification
```
Vendor provides:   1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11
Your calculation:  1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11
‚úÖ Match = File is intact and authentic

Your calculation:  9d8f7e6a5b4c3d2e1f0a9b8c7d6e5f4a3b2c1d0e9f8a7b6c5d4e3f2a1b0c9d8e
‚ùå Mismatch = File was modified/corrupted/malicious
```

#### 2. Malware Detection
- Security researchers share hashes of known malware
- Antivirus databases contain millions of malware hashes
- If your file matches a known malicious hash ‚Üí it's malware

#### 3. Password Storage (Don't store plaintext!)
```
User enters password: "MyPassword123"
Website stores hash:  "ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f"

Login attempt:
User enters: "MyPassword123"
Hash it:     "ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f"
Compare:     ‚úÖ Match = Login successful
```

#### 4. Digital Forensics
- Prove evidence wasn't tampered with
- Chain of custody in legal cases
- Verify backup integrity

#### 5. Blockchain & Cryptocurrency
- Bitcoin uses SHA256 for mining
- Each block contains hash of previous block
- Immutable ledger

### Real-World Scenario

**Imagine you're a security analyst:**

1. A router in your network was compromised
2. You extract the firmware from the suspect device
3. You need to verify if system binaries were modified by attackers
4. You calculate SHA256 hashes of critical files
5. Compare with hashes from the official vendor firmware

**If hashes match:**
- ‚úÖ Files are original and unmodified
- ‚úÖ No backdoors or malware detected

**If hashes don't match:**
- ‚ùå Files were tampered with
- ‚ùå Possible backdoor, rootkit, or malware
- ‚ùå Device is compromised - investigate further!

---

## Solution Summary

### Complete Command Sequence

```bash
# Phase 1: Identify file type
file blockshire_router_firmware.bin
# Output: POSIX tar archive (GNU)

# Phase 2: Extract TAR archive
mkdir firmware_extracted
tar -xvf blockshire_router_firmware.bin -C firmware_extracted/
cd firmware_extracted/sysupgrade-meraki_mr32/

# Phase 3: Identify filesystem type
file root
# Output: Squashfs filesystem, little endian, version 4.0, xz compressed

binwalk root
# Confirms SquashFS at offset 0x0

# Phase 4: Extract SquashFS filesystem
unsquashfs -d squashfs-root root

# Phase 5: Find netdata executable
find squashfs-root -type f -iname "*netdata*"
# Found: squashfs-root/usr/sbin/netdata

# Verify it's an executable
file squashfs-root/usr/sbin/netdata
# Output: ELF 32-bit LSB executable, ARM...

# Phase 6: Calculate SHA256 hash
sha256sum squashfs-root/usr/sbin/netdata
# Output: 1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11
```

### Solution Flow Diagram

```
blockshire_router_firmware.bin (TAR archive)
    ‚îÇ
    ‚îú‚îÄ file command ‚Üí Identify as TAR
    ‚îÇ
    ‚îî‚îÄ tar -xvf ‚Üí Extract
              ‚îÇ
              ‚îî‚îÄ sysupgrade-meraki_mr32/
                      ‚îú‚îÄ CONTROL (metadata)
                      ‚îú‚îÄ kernel (Linux kernel)
                      ‚îî‚îÄ root (SquashFS) ‚≠ê
                              ‚îÇ
                              ‚îú‚îÄ file command ‚Üí Identify as SquashFS
                              ‚îú‚îÄ binwalk ‚Üí Confirm structure
                              ‚îÇ
                              ‚îî‚îÄ unsquashfs ‚Üí Extract
                                      ‚îÇ
                                      ‚îî‚îÄ squashfs-root/
                                              ‚îú‚îÄ bin/
                                              ‚îú‚îÄ etc/
                                              ‚îú‚îÄ lib/
                                              ‚îî‚îÄ usr/
                                                  ‚îî‚îÄ sbin/
                                                      ‚îî‚îÄ netdata ‚≠ê‚≠ê
                                                          ‚îÇ
                                                          ‚îî‚îÄ sha256sum
                                                              ‚îÇ
                                                              ‚îî‚îÄ 1cb66aec...db11
```

### The Flag

```
Exploit3rs{1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11}
```

---

## Key Takeaways

### Tools Learned

| Tool | Purpose | Usage |
|------|---------|-------|
| `file` | Identify file types | `file filename` |
| `tar` | Extract TAR archives | `tar -xvf archive.tar` |
| `binwalk` | Analyze firmware for embedded files | `binwalk filename` |
| `unsquashfs` | Extract SquashFS filesystems | `unsquashfs -d output_dir input_file` |
| `find` | Search for files | `find path -name "pattern"` |
| `sha256sum` | Calculate SHA256 hash | `sha256sum filename` |

### Key Concepts

1. **Firmware Structure**
   - Firmware is a packaged operating system for embedded devices
   - Contains kernel, filesystem, and configuration
   - Often uses compressed, read-only filesystems like SquashFS

2. **File Signatures (Magic Bytes)**
   - First few bytes identify file type
   - Don't trust file extensions
   - Use `file` command to verify

3. **Nested Archives**
   - Firmware often contains multiple layers
   - TAR ‚Üí SquashFS ‚Üí Individual files
   - Extract layer by layer

4. **Filesystem Hierarchy**
   - `/bin/`, `/sbin/` - Executables
   - `/etc/` - Configuration
   - `/usr/sbin/` - System administration programs
   - Understanding this helps locate target files

5. **Cryptographic Hashes**
   - One-way functions for file integrity
   - SHA256 produces unique fingerprint
   - Essential for security verification

### Common Mistakes to Avoid

‚ùå **Trusting file extensions**
```bash
# Don't assume .bin is always an executable
# Always use: file filename
```

‚ùå **Trying to cd into a file**
```bash
cd root  # WRONG - root is a file, not a directory
cd squashfs-root/  # CORRECT - this is the extracted directory
```

‚ùå **Not using the right extraction tool**
```bash
# SquashFS needs unsquashfs, not tar
# TAR archives need tar, not unsquashfs
```

‚ùå **Ignoring file command output**
```bash
# Always check what you're working with before proceeding
file unknown_file
```

‚ùå **Searching in the wrong location**
```bash
# Search in extracted directory, not the compressed file
find squashfs-root -name "target"  # CORRECT
find root -name "target"  # WRONG
```

### Skills Developed

‚úÖ **Firmware Analysis**
- Extracting and analyzing router firmware
- Understanding embedded device filesystems
- Navigating Linux filesystem hierarchy

‚úÖ **Reverse Engineering Methodology**
- Systematic approach to unknown binaries
- Layer-by-layer extraction
- Tool selection based on file type

‚úÖ **File System Forensics**
- Identifying file types
- Extracting nested archives
- Searching for specific files

‚úÖ **Cryptographic Verification**
- Calculating file hashes
- Understanding hash properties
- Using hashes for integrity verification

---

## Additional Resources

### Tools to Install

```bash
# Essential firmware analysis tools
sudo apt update
sudo apt install -y \
    binwalk \
    squashfs-tools \
    file \
    tar \
    coreutils
```

### Further Learning

1. **Firmware Analysis**
   - [Binwalk Documentation](https://github.com/ReFirmLabs/binwalk)
   - [Firmware Analysis Toolkit](https://github.com/attify/firmware-analysis-toolkit)

2. **Reverse Engineering**
   - [Ghidra](https://ghidra-sre.org/) - NSA's reverse engineering tool
   - [radare2](https://rada.re/n/) - Open-source RE framework

3. **Cryptography**
   - [SHA-2 Wikipedia](https://en.wikipedia.org/wiki/SHA-2)
   - [Cryptographic Hash Functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function)

4. **Linux Filesystem**
   - [Filesystem Hierarchy Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)
   - [Linux Directory Structure](https://www.pathname.com/fhs/)

### Practice Challenges

- **RouterSploit** - Router exploitation framework
- **Damn Vulnerable Router Firmware (DVRF)** - Practice firmware analysis
- **Embedded Security CTF** - More firmware challenges
- **picoCTF** - Beginner-friendly reverse engineering challenges

---

## Conclusion

This challenge simulates a real-world firmware analysis scenario where you need to:

1. Extract router firmware
2. Navigate its filesystem structure
3. Locate critical system binaries
4. Verify file integrity using cryptographic hashes

These skills are essential for:
- **IoT Security** - Analyzing smart device firmware
- **Incident Response** - Investigating compromised devices
- **Vulnerability Research** - Finding bugs in embedded systems
- **Digital Forensics** - Examining evidence from devices

The methodical approach learned here applies to any firmware analysis task:
**Identify ‚Üí Extract ‚Üí Analyze ‚Üí Verify**

Keep practicing, and you'll master firmware reverse engineering! üöÄ

---

**Author:** CTF Beginner  
**Date:** November 2, 2025  
**Challenge:** Nether Network Mystery  
**Category:** Reverse Engineering / Firmware Analysis  
**Difficulty:** Medium  

**Flag:** `Exploit3rs{1cb66aecf26f95d8d727e7508a85f5357737c88ab768380928a47b4df038db11}`

---

## Quick Reference Command Cheat Sheet

```bash
# File identification
file <filename>

# TAR extraction
tar -xvf <archive.tar> -C <destination_folder>

# Firmware analysis
binwalk <filename>
binwalk -e <filename>  # Extract

# SquashFS extraction
unsquashfs -d <output_dir> <squashfs_file>

# File search
find <directory> -name "<pattern>"
find <directory> -type f -iname "<pattern>"  # Case-insensitive, files only

# Hash calculation
sha256sum <filename>
md5sum <filename>
sha1sum <filename>

# File verification
file <filename>  # Check file type
ls -lh <filename>  # Check size and permissions
strings <filename>  # Extract readable strings
hexdump -C <filename> | head  # View hex dump
```
