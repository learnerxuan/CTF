# PIE TIME Binary Exploitation Challenge Writeup

## Challenge Overview 
**Description:** Can you try to get the flag? Beware we have PIE ! A binary with Position Independent Execution (PIE) protection must be exploited to access the flag.

## Initial Analysis

First, I examined the binary using the `file` command to understand its properties:

![Binary file information](https://github.com/user-attachments/assets/9618a682-9779-4924-b91d-e29eeb78a66e)

From this output, I gathered the following information:
- **ELF 64-bit LSB executable**: A Linux binary in the ELF format, compiled for 64-bit architecture
- **PIE enabled**: Position Independent Execution means addresses of functions and global variables change on each execution due to ASLR
- **Dynamically linked**: Uses shared libraries instead of static linking
- **Not stripped**: Contains debugging symbols, making analysis easier

## Source Code Analysis

The challenge provided the following source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}  
```

### Code Breakdown:

#### Included Headers:
- `<stdio.h>`: Standard I/O functions
- `<stdlib.h>`: General utility functions
- `<signal.h>`: Signal handling functions
- `<unistd.h>`: System call interfaces

#### Key Functions:

1. **`segfault_handler()`**
   - Signal handler for segmentation faults (SIGSEGV)
   - Prevents program crashes by providing a controlled exit when invalid memory is accessed

2. **`win()`**
   - Target function that reads and displays the flag
   - Opens "flag.txt", reads its contents character by character, and prints them

3. **`main()`**
   - Sets up signal handler for segmentation faults
   - Disables output buffering
   - **Reveals the current address of `main()`** - crucial for our exploit!
   - Asks user for a memory address
   - **Creates a function pointer from the user input and executes it**

## Vulnerability Analysis

The vulnerability lies in the `main()` function:

```c
void (*foo)(void) = (void (*)())val;
foo();
```

This code creates a function pointer from user input and calls it. The program is asking us to provide an address to jump to. The goal is to execute the `win()` function, which will print the flag.

Since PIE is enabled, the address of `win()` changes with each execution. However, the program helpfully prints the address of `main()`, which we can use as a reference point.

## Exploitation Strategy

While the absolute addresses change with each execution due to PIE, the relative offset between functions in the same binary remains constant. Our strategy:

1. Find the offset between `main()` and `win()`
2. At runtime, calculate the address of `win()` based on the revealed address of `main()`
3. Provide the calculated address to the program

## Exploit Development

### Step 1: Finding the Offset

Using GDB, I disassembled both functions to find their starting addresses:

![Main function disassembly](https://github.com/user-attachments/assets/145c90d4-e96c-4942-9a73-478fa135ab54)

![Win function disassembly](https://github.com/user-attachments/assets/055f18f6-4fa9-45f2-a2f5-be864234cf9e)

From the disassembly:
- `main()` starts at: `0x000000000000133d`
- `win()` starts at: `0x00000000000012a7`

Calculating the offset:
```
offset = main - win
       = 0x000000000000133d - 0x00000000000012a7
       = 0x96 (150 in decimal)
```

This means `main()` is always 0x96 bytes higher in memory than `win()` in this binary.

### Step 2: Running the Exploit

I connected to the remote server:
```
nc rescued-float.picoctf.net 59611
```

When the program executed, it revealed the current address of `main()`. Using the offset calculated earlier, I determined the address of `win()`:

![Exploit execution](https://github.com/user-attachments/assets/42bc9875-dfd1-4a1a-a8e3-234df89cb30b)

```
win = main - offset
    = 0x5684eb87233d - 0x96
    = 0x5684eb872a7
```

I provided this calculated address to the program, which then jumped to the `win()` function and printed the flag:

![Flag revealed](https://github.com/user-attachments/assets/91fd966f-425a-4672-a07f-cb902cc2675a)

## Key Takeaways

1. **PIE Bypass Technique**: Even with PIE enabled, if a program leaks the address of any function, you can use relative offsets to calculate the addresses of other functions.

2. **Function Pointer Vulnerabilities**: Allowing user input to control function pointers creates a direct code execution vulnerability.

3. **Binary Analysis Skills**: Understanding assembly code and using tools like GDB are essential for calculating the correct offsets between functions.

## Tools Used
- GDB: For disassembling the binary and finding function addresses
- Basic arithmetic: For calculating offsets between functions
- nc (netcat): For connecting to the remote server
