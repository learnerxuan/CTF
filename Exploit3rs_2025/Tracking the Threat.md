# Tracking the Threat - CTF Challenge Writeup

## Challenge Information

- **Challenge Name:** Tracking the Threat
- **Category:** Forensics / Digital Forensics
- **Points:** 350
- **Difficulty:** Medium

### Challenge Description

> The captain has ordered you to investigate suspicious activity on the battlefield's command center. Malicious activity has been detected, and the team suspects an enemy backdoor. Using the provided prefetch data, find the evidence of the malicious executable and report its full directory path.

**Flag Format:** `Exploit3rs{C:\full_directory_path\malicious.exe}`

---

## Table of Contents

1. [Background Knowledge](#background-knowledge)
2. [Initial Analysis](#initial-analysis)
3. [Technical Investigation](#technical-investigation)
4. [Solution](#solution)
5. [Key Takeaways](#key-takeaways)
6. [References](#references)

---

## Background Knowledge

### What are Windows Prefetch Files?

Windows Prefetch is a performance optimization feature introduced in Windows XP that helps applications load faster. When you run a program, Windows monitors what files it accesses during the first ~10 seconds of execution and creates a "prefetch file" (.pf) to speed up future launches.

#### Why Prefetch Files are Forensic Gold ðŸ†

Even if an attacker deletes their malware, the prefetch file remains as evidence!

**What Prefetch Files Contain:**
- âœ… Executable name
- âœ… **Full path** where it was executed from
- âœ… DLL files and resources loaded
- âœ… Timestamps (first run, last 8 runs)
- âœ… Execution count

**Example:**
```
If malware runs from: C:\Users\Victim\Downloads\evil.exe
Prefetch file created: C:\Windows\Prefetch\EVIL.EXE-12345678.pf
```

Even if `evil.exe` is deleted, the prefetch file proves:
1. The malware executed on this system
2. Where it was located
3. When it ran
4. How many times it executed

### Prefetch File Naming Convention

```
EXECUTABLE_NAME.EXE-HASH.pf
```

- **EXECUTABLE_NAME.EXE:** The name of the program
- **HASH:** 8-character hex hash based on the full path
- **.pf:** Prefetch file extension

**Example:**
```
NOTEPAD.EXE-A325D85A.pf
CHROME.EXE-B4F8D9E2.pf
B@CKD00R.EXE-7CB4E6DE.pf  â† Our malware!
```

### Prefetch File Formats

Windows has evolved its prefetch format over time:

| Windows Version | Format | Header | Compression | Max Files |
|----------------|---------|---------|-------------|-----------|
| XP/Vista/7 | SCCA | `SCCA` (0x53434341) | None | 128 |
| 8/8.1 | MAM | `MAM` + version | Compressed | 1024 |
| 10/11 | MAM v4 | `MAM\x04` (0x4D414D04) | Xpress | 1024 |

**Our challenge uses Windows 10/11 format (MAM\x04)** which requires decompression before analysis.

### Understanding Volume Paths

Prefetch files use **Volume GUIDs** instead of drive letters:

```
Traditional Path:    C:\Users\Bob\file.exe
Volume Path:         \VOLUME{01d926fadbedf1a6-68dc08d5}\USERS\BOB\FILE.EXE
```

**Why Volume GUIDs?**

Drive letters (C:, D:, E:) can change, but Volume GUIDs are permanent and unique to each physical drive/partition. This helps forensic investigators track which specific drive was used, even if drive letters were reassigned.

**Conversion:**
- `\VOLUME{...}\` typically represents `C:\` (the system drive)
- You can confirm this by looking for system files like `\WINDOWS\SYSTEM32\`

---

## Initial Analysis

### Step 1: Extract the Evidence

```bash
unrar x challenge.rar challenge_contents/
```

This extracts the RAR archive containing prefetch files from the compromised system.

**Output:**
```
Extracting  challenge_contents/Prefetch/Prefetch/NOTEPAD.EXE-A325D85A.pf  OK
Extracting  challenge_contents/Prefetch/Prefetch/CHROME.EXE-12345678.pf  OK
Extracting  challenge_contents/Prefetch/Prefetch/B@CKD00R.EXE-7CB4E6DE.pf  OK
... (many more files)
```

### Step 2: Navigate to Prefetch Directory

```bash
cd challenge_contents/Prefetch/Prefetch/
ls -la
```

### Step 3: Identify Suspicious Files

Scanning through the extracted files, one immediately stands out:

```
B@CKD00R.EXE-7CB4E6DE.pf
```

**Red Flags:** ðŸš©
- Obvious malicious name: "BACKDOOR" with `@` replacing `A`
- Not a standard Windows executable
- Clearly suspicious

**Legitimate Examples for Comparison:** âœ…
- `NOTEPAD.EXE-*.pf` - Windows built-in text editor
- `CHROME.EXE-*.pf` - Web browser
- `EXPLORER.EXE-*.pf` - Windows file explorer

---

## Technical Investigation

### Step 1: Examine File Format

First, let's check what format this prefetch file uses:

```bash
hexdump -C "B@CKD00R.EXE-7CB4E6DE.pf" | head -1
```

**Output:**
```
00000000  4d 41 4d 04 fe 26 00 00  94 b7 b5 ab a8 a7 bb 00  |MAM..&..........|
          â†‘  â†‘  â†‘  â†‘
          M  A  M  \x04
```

**Analysis:**
- Header: `4D 41 4D 04` = "MAM\x04" in ASCII
- This is **Windows 10/11 compressed format**
- Requires decompression before parsing

### Step 2: Why Simple String Extraction Fails

Let's try the naive approach:

```bash
strings -a "B@CKD00R.EXE-7CB4E6DE.pf"
```

**Output:**
```
I,`9D
7|0vXdHl|
h3)	J
4,E*
```

âŒ **Result:** Garbage! The file is compressed.

**Comparison with Uncompressed Prefetch (Windows 7):**

If this were an uncompressed SCCA format, `strings` would show readable paths like:
```
C:\Windows\System32\notepad.exe
C:\Windows\System32\kernel32.dll
```

This confirms we need a specialized tool to decompress and parse the file.

### Step 3: Install Prefetch Parser

We need `libscca-python`, a library that can:
- âœ… Detect prefetch format automatically
- âœ… Decompress MAM compressed files
- âœ… Parse internal structure
- âœ… Extract metadata and file paths

```bash
pip3 install libscca-python
```

**Note:** The `windowsprefetch` library requires Windows APIs for decompression, so it won't work on Linux. `libscca-python` works cross-platform.

### Step 4: Create Parser Script

Create a Python script to parse the prefetch file:

```bash
cat > ~/parse_pf_libscca.py << 'EOF'
#!/usr/bin/env python3
import pyscca
import sys

def parse_prefetch(filename):
    try:
        # Open the prefetch file
        scca_file = pyscca.file()
        scca_file.open(filename)
        
        # Print basic metadata
        print(f"Executable: {scca_file.executable_filename}")
        print(f"Prefetch hash: {scca_file.prefetch_hash:08X}")
        print(f"Run count: {scca_file.run_count}")
        print(f"Number of file references: {scca_file.number_of_file_metrics_entries}")
        
        # Extract all file references
        print("\n=== File References ===")
        for i in range(scca_file.number_of_file_metrics_entries):
            try:
                file_metric = scca_file.get_file_metrics_entry(i)
                filename = file_metric.filename
                print(f"  {filename}")
                
                # Highlight if it contains the backdoor
                if 'B@CKD00R' in filename.upper() or 'BACKD00R' in filename.upper():
                    print(f"\n*** MALICIOUS EXECUTABLE PATH: {filename} ***\n")
            except:
                pass
        
        scca_file.close()
        
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 parse_pf_libscca.py <prefetch_file>")
        sys.exit(1)
    
    parse_prefetch(sys.argv[1])
EOF

chmod +x ~/parse_pf_libscca.py
```

### Step 5: Parse the Prefetch File

```bash
cd ~/exploit3_CTF2025/Tracking_the_Threat/challenge_contents/Prefetch/Prefetch/
python3 ~/parse_pf_libscca.py "B@CKD00R.EXE-7CB4E6DE.pf"
```

**Output:**
```
Executable: B@CKD00R.EXE
Prefetch hash: 7CB4E6DE
Run count: 1
Number of file references: 24

=== File References ===
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\NTDLL.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\C_1252.NLS
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\C_437.NLS
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\L_INTL.NLS
  \VOLUME{01d926fadbedf1a6-68dc08d5}\$MFT
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\WOW64.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\WOW64BASE.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\WOW64WIN.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\WOW64CON.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\KERNEL32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\KERNEL32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\USER32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\WOW64CPU.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\NTDLL.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\KERNELBASE.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\LOCALE.NLS
  \VOLUME{01d926fadbedf1a6-68dc08d5}\USERS\ABIGAIL_FORBES\DESKTOP\SECRET\B@CKD00R.EXE

*** MALICIOUS EXECUTABLE PATH: \VOLUME{01d926fadbedf1a6-68dc08d5}\USERS\ABIGAIL_FORBES\DESKTOP\SECRET\B@CKD00R.EXE ***

  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\MSVCRT.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\ADVAPI32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\SECHOST.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\RPCRT4.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\WS2_32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\WSOCK32.DLL
  \VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSWOW64\MSWSOCK.DLL
```

### Analysis of Findings

#### 1. Execution Metadata
```
Executable: B@CKD00R.EXE
Run count: 1
```
- The malware was executed **once**
- Helps establish attack timeline

#### 2. The Malicious Path
```
\VOLUME{01d926fadbedf1a6-68dc08d5}\USERS\ABIGAIL_FORBES\DESKTOP\SECRET\B@CKD00R.EXE
```

**Breaking it down:**
- **Volume GUID:** `01d926fadbedf1a6-68dc08d5` (represents C: drive)
- **User:** `ABIGAIL_FORBES`
- **Location:** `\DESKTOP\SECRET\`
- **File:** `B@CKD00R.EXE`

**Why is this suspicious?** ðŸš©
- Executables should NOT be on the Desktop
- Hidden in a folder named "Secret"
- User's personal space, not system directories

#### 3. Network Activity Indicators
```
\WINDOWS\SYSWOW64\WS2_32.DLL
\WINDOWS\SYSWOW64\WSOCK32.DLL
\WINDOWS\SYSWOW64\MSWSOCK.DLL
```

**These are Windows Socket libraries!**
- The malware used **network functionality**
- Confirms it's likely a backdoor communicating with an attacker's C2 server

#### 4. Architecture
```
\WINDOWS\SYSWOW64\...
```
- Multiple references to `SYSWOW64`
- Indicates a **32-bit executable** running on 64-bit Windows
- WOW64 = Windows-on-Windows 64-bit (compatibility layer)

### Step 6: Convert Volume Path to Standard Windows Format

**Volume Path:**
```
\VOLUME{01d926fadbedf1a6-68dc08d5}\USERS\ABIGAIL_FORBES\DESKTOP\SECRET\B@CKD00R.EXE
```

**How do we know it's C: drive?**

Look at the system files referenced:
```
\VOLUME{01d926fadbedf1a6-68dc08d5}\WINDOWS\SYSTEM32\NTDLL.DLL
```

`\WINDOWS\SYSTEM32\` **only exists on C:** (the boot/system drive).

**Conversion:**
```
\VOLUME{01d926fadbedf1a6-68dc08d5}\ â†’ C:\
\USERS\ â†’ \Users\  (proper Windows casing)
ABIGAIL_FORBES â†’ Abigail_Forbes  (Windows naming convention)
```

**Standard Windows Path:**
```
C:\Users\Abigail_Forbes\Desktop\Secret\B@CKD00R.EXE
```

---

## Solution

### The Flag

```
Exploit3rs{C:\Users\Abigail_Forbes\Desktop\Secret\B@CKD00R.EXE}
```

### Forensic Report Summary

**INCIDENT REPORT: Malicious Backdoor Detected**

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXECUTIVE SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Executable Name:    B@CKD00R.EXE
Full Path:          C:\Users\Abigail_Forbes\Desktop\Secret\B@CKD00R.EXE
Prefetch Hash:      7CB4E6DE
User Account:       Abigail_Forbes

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXECUTION DETAILS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Run Count:          1 (executed once)
File References:    24 files accessed
Architecture:       32-bit (running via WOW64)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
THREAT INDICATORS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Suspicious Location:  User's Desktop\Secret\ folder
âœ“ Network Capability:   Loaded WS2_32.DLL, WSOCK32.DLL, MSWSOCK.DLL
âœ“ Obvious Naming:       "BACKDOOR" in filename
âœ“ Hidden Folder:        Stored in folder named "Secret"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
THREAT ASSESSMENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Risk Level: HIGH

- Name explicitly indicates backdoor functionality
- Network communication capability suggests C2 (Command & Control)
- Hidden in user's personal directory to avoid detection
- 32-bit executable may be attempting to evade 64-bit security tools

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RECOMMENDATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Immediately isolate system from network
2. Conduct full malware analysis in sandboxed environment
3. Review network logs for C2 communications
4. Investigate user account "Abigail_Forbes" for compromise
5. Check for persistence mechanisms (registry, scheduled tasks)
6. Scan for additional indicators of compromise (IOCs)
7. Review access logs and authentication events
```

---

## Key Takeaways

### Forensic Techniques Learned

1. **Windows Prefetch Analysis**
   - Prefetch files survive even after malware deletion
   - Contain executable path, timestamps, and loaded files
   - Critical for incident response and timeline reconstruction

2. **Prefetch File Formats**
   - Windows 10/11 uses MAM compression
   - Cannot parse with simple `strings` command
   - Requires specialized tools (libscca-python)

3. **Volume Path Interpretation**
   - Volume GUIDs provide permanent drive identification
   - More reliable than drive letters for forensics
   - Can be converted to standard Windows paths

4. **Malware Indicators**
   - Suspicious executable names
   - Unusual file locations (Desktop, Downloads, Temp)
   - Network DLL usage indicates C2 capability
   - Multiple execution indicators strengthen case

### Red Flags for Malware Detection

**ðŸš© Suspicious Executable Locations:**
- `C:\Users\*\Desktop\`
- `C:\Users\*\Downloads\`
- `C:\Users\*\AppData\Roaming\RandomFolder\`
- `C:\Temp\`
- `C:\ProgramData\` (unless it's legitimate software)

**âœ… Legitimate Executable Locations:**
- `C:\Windows\System32\`
- `C:\Program Files\`
- `C:\Program Files (x86)\`

**ðŸš© Suspicious Naming Patterns:**
- Random characters: `x7f9k2.exe`, `temp123.exe`
- Misspellings: `scvhost.exe` (should be `svchost.exe`)
- Obvious malicious names: `backdoor.exe`, `keylogger.exe`

**ðŸš© Network Activity Indicators:**
- `WS2_32.DLL` - Windows Sockets
- `WSOCK32.DLL` - Legacy Winsock
- `WININET.DLL` - Internet functions
- `URLMON.DLL` - URL moniker services

### Command Reference

**Complete Investigation Workflow:**

```bash
# 1. Extract evidence
unrar x challenge.rar challenge_contents/

# 2. Navigate to prefetch directory
cd challenge_contents/Prefetch/Prefetch/

# 3. Check file format
hexdump -C "suspicious.pf" | head -1

# 4. Install parsing library (one-time)
pip3 install libscca-python

# 5. Create parser script
cat > ~/parse_pf_libscca.py << 'EOF'
#!/usr/bin/env python3
import pyscca
import sys

def parse_prefetch(filename):
    try:
        scca_file = pyscca.file()
        scca_file.open(filename)
        
        print(f"Executable: {scca_file.executable_filename}")
        print(f"Prefetch hash: {scca_file.prefetch_hash:08X}")
        print(f"Run count: {scca_file.run_count}")
        print(f"Number of file references: {scca_file.number_of_file_metrics_entries}")
        
        print("\n=== File References ===")
        for i in range(scca_file.number_of_file_metrics_entries):
            try:
                file_metric = scca_file.get_file_metrics_entry(i)
                filename = file_metric.filename
                print(f"  {filename}")
            except:
                pass
        
        scca_file.close()
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 parse_pf_libscca.py <prefetch_file>")
        sys.exit(1)
    
    parse_prefetch(sys.argv[1])
EOF

chmod +x ~/parse_pf_libscca.py

# 6. Parse the prefetch file
python3 ~/parse_pf_libscca.py "suspicious.pf"

# 7. Convert volume path to Windows format
# \VOLUME{...}\ â†’ C:\
```

---

## References

### Tools Used

- **unrar** - Extract RAR archives
- **hexdump** - View binary file contents
- **libscca-python (pyscca)** - Parse Windows Prefetch files
  - GitHub: https://github.com/libyal/libscca
  - Install: `pip3 install libscca-python`

### Alternative Tools

- **PECmd** (Windows only) - Eric Zimmerman's Prefetch Parser
  - Download: https://ericzimmerman.github.io/
  - Usage: `PECmd.exe -f prefetch.pf`

- **WinPrefetchView** (Windows GUI) - NirSoft tool
  - Download: https://www.nirsoft.net/utils/win_prefetch_view.html

### Learning Resources

- **SANS Digital Forensics** - Prefetch Analysis
  - https://www.sans.org/

- **13Cubed YouTube** - Windows Forensics tutorials
  - https://www.youtube.com/c/13cubed

- **Libyal Projects** - Digital forensics libraries
  - https://github.com/libyal

### Forensic Artifacts Documentation

- Windows Prefetch location: `C:\Windows\Prefetch\`
- Maximum files: 128 (Win7), 1024 (Win8+)
- Monitoring window: ~10 seconds after execution
- Timestamps available: First run + last 8 runs (Win8+)

---

## Practice Exercise

**Challenge:** You find a prefetch file named `SVCHOST.EXE-ABCD1234.pf`

When parsed, it shows:
```
Path: C:\Users\Bob\Downloads\svchost.exe
Run count: 3
Network DLLs: WS2_32.DLL, WININET.DLL
```

**Questions:**
1. Is this suspicious? Why?
2. What are the red flags?
3. What would you investigate next?

**Answers:**
1. **Yes, highly suspicious!**
   - `svchost.exe` should ONLY exist in `C:\Windows\System32\`
   - Finding it in Downloads is a classic malware technique (name mimicking)

2. **Red Flags:**
   - Wrong location (Downloads folder)
   - Network DLL usage (legitimate svchost typically uses different APIs)
   - Run count of 3 suggests repeated execution
   - User directory instead of system directory

3. **Next Steps:**
   - Check if legitimate `C:\Windows\System32\svchost.exe` exists
   - Compare file hashes
   - Review network logs for C2 traffic
   - Check Bob's account for compromise
   - Look for persistence mechanisms (scheduled tasks, registry)
   - Scan for additional malware

---

## Conclusion

This challenge demonstrated the critical role of Windows Prefetch files in digital forensics. Even though the malicious executable may have been deleted, the prefetch file preserved crucial evidence including:

- âœ… The executable's full path
- âœ… Proof of execution
- âœ… Network activity indicators
- âœ… User account involved

**Key Lesson:** Always check prefetch files during incident response - they're often the "smoking gun" that proves malware execution, even when the malware itself has been removed.

---

**Flag:** `Exploit3rs{C:\Users\Abigail_Forbes\Desktop\Secret\B@CKD00R.EXE}`
