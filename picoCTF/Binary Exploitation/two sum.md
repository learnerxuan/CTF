# Two Sum - PicoCTF Integer Overflow Challenge

## Challenge Information

- **Name:** Two Sum
- **Category:** Binary Exploitation / Reverse Engineering
- **Description:** Can you solve this? Additional details will be available after launching your challenge instance.

## Challenge Prompt

The program asks us to find two positive numbers that make this condition true:
```
n1 > n1 + n2 OR n2 > n1 + n2
```

At first glance, this seems mathematically impossible. How can a number be greater than itself plus another positive number? The answer lies in **integer overflow**.

## Source Code Analysis

```c
#include <stdio.h>
#include <stdlib.h>

static int addIntOvf(int result, int a, int b) {
    result = a + b;
    if(a > 0 && b > 0 && result < 0)
        return -1;
    if(a < 0 && b < 0 && result > 0)
        return -1;
    return 0;
}

int main() {
    int num1, num2, sum;
    FILE *flag;
    char c;
    printf("n1 > n1 + n2 OR n2 > n1 + n2 \n");
    fflush(stdout);
    printf("What two positive numbers can make this possible: \n");
    fflush(stdout);
    
    if (scanf("%d", &num1) && scanf("%d", &num2)) {
        printf("You entered %d and %d\n", num1, num2);
        fflush(stdout);
        sum = num1 + num2;
        if (addIntOvf(sum, num1, num2) == 0) {
            printf("No overflow\n");
            fflush(stdout);
            exit(0);
        } else if (addIntOvf(sum, num1, num2) == -1) {
            printf("You have an integer overflow\n");
            fflush(stdout);
        }
        if (num1 > 0 || num2 > 0) {
            flag = fopen("flag.txt","r");
            if(flag == NULL){
                printf("flag not found: please run this on the server\n");
                fflush(stdout);
                exit(0);
            }
            char buf[60];
            fgets(buf, 59, flag);
            printf("YOUR FLAG IS: %s\n", buf);
            fflush(stdout);
            exit(0);
        }
    }
    return 0;
}
```

## Understanding Integer Overflow

### What is Integer Overflow?

In C, an `int` is typically a 32-bit signed integer that can hold values from:
- **Minimum:** -2,147,483,648 (`-2^31`)
- **Maximum:** 2,147,483,647 (`2^31 - 1`)

When you try to store a value larger than the maximum, it "wraps around" to the negative range. This is called **integer overflow**.

### Example of Integer Overflow

```
2,147,483,647 + 1 = -2,147,483,648 (not 2,147,483,648!)
```

This wrapping behavior is what makes the seemingly impossible condition possible:
- If `n1 = 2,000,000,000` and `n2 = 2,000,000,000`
- Then `n1 + n2 = 4,000,000,000` (mathematically)
- But due to overflow: `n1 + n2 = -294,967,296` (in the program) # Two's Complement, haha I learned during Diploma, Math class
- Now `n1 > n1 + n2` becomes `2,000,000,000 > -294,967,296` which is **TRUE**!

## Code Flow Analysis

### Step 1: Input Validation
```c
if (scanf("%d", &num1) && scanf("%d", &num2)) {
    // Process inputs
}
```
The program reads two integers from user input.

### Step 2: Sum Calculation
```c
sum = num1 + num2;
```
This is where the overflow occurs if our numbers are large enough.

### Step 3: Overflow Detection
```c
static int addIntOvf(int result, int a, int b) {
    result = a + b;  // Note: 'result' parameter is passed by value
    if(a > 0 && b > 0 && result < 0)  // Positive overflow detection
        return -1;
    if(a < 0 && b < 0 && result > 0)  // Negative overflow detection
        return -1;
    return 0;  // No overflow detected
}
```

**Key Points:**
- The function detects when two positive numbers add up to a negative result
- Returns `-1` if overflow is detected, `0` otherwise
- The `result` parameter receives the already-calculated sum from `main()`

### Step 4: Flag Condition
```c
if (num1 > 0 || num2 > 0) {
    // Print flag
}
```
This condition is easily satisfied with positive numbers, so the real challenge is triggering the overflow detection.

## Solution Strategy

To get the flag, we need to:
1. **Trigger integer overflow** - Make `addIntOvf()` return `-1`
2. **Use positive numbers** - Satisfy the final condition `(num1 > 0 || num2 > 0)`

### Choosing the Right Numbers

We need two positive numbers whose sum exceeds `2,147,483,647`. Good candidates:
- `2,000,000,000 + 2,000,000,000 = 4,000,000,000` (overflows to negative)
- `1,500,000,000 + 1,500,000,000 = 3,000,000,000` (overflows to negative)

## Solution
![image](https://github.com/user-attachments/assets/718e16e6-4c13-431e-ba30-c4066ddc1af9)

### Step-by-Step Execution

1. **Input:** `num1 = 2000000000`, `num2 = 2000000000`
2. **Sum calculation:** `sum = 2000000000 + 2000000000 = -294967296` (due to overflow)
3. **Overflow detection:** `addIntOvf(-294967296, 2000000000, 2000000000)`
   - `a > 0` âœ“ (2000000000 > 0)
   - `b > 0` âœ“ (2000000000 > 0)  
   - `result < 0` âœ“ (-294967296 < 0)
   - Returns `-1` (overflow detected)
4. **Flag condition:** `(2000000000 > 0 || 2000000000 > 0)` = `TRUE`
5. **Result:** Flag is printed!

## Alternative Solutions

Any two positive integers whose sum exceeds `2,147,483,647` will work:

```bash
# Option 1
2147483647
1

# Option 2  
1000000000
2000000000

# Option 3
2100000000
2100000000
```

## Key Learning Points

1. **Integer Overflow:** Understanding how integer overflow causes wrap-around behavior
2. **Signed Integer Limits:** Knowing the range of 32-bit signed integers
3. **Exploitation Logic:** Using overflow to make impossible conditions possible
4. **Code Analysis:** Reading C code to understand program flow and vulnerabilities

---

**Flag obtained successfully! This challenge demonstrates how integer overflow can lead to unexpected behavior in programs.** ðŸš©
