# PIE TIME 2 - Advanced PIE Binary Exploitation Writeup

## Challenge Overview
**Name:** "Can you try to get the flag? I'm not revealing anything anymore!!"  
**Description:** A follow-up to PIE TIME with enhanced security - no address leak is provided this time.

## Initial Analysis

First, I examined the binary properties using the `file` command:

![Binary file information](https://github.com/user-attachments/assets/d2f3f457-6666-4fd7-acf8-d9bec932f135)

Similar to the previous challenge, this is a PIE-enabled 64-bit ELF binary. However, when connecting to the challenge, I noticed a key difference:

![Challenge connection](https://github.com/user-attachments/assets/a50af11b-9805-4187-8314-2a61c8c614c2)

Unlike PIE TIME, this challenge **does not reveal the address of `main()`**, making exploitation more challenging.

## Source Code Analysis

The challenge provided the following source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```

### Vulnerability Analysis

This challenge introduces **two vulnerabilities**:

#### 1. Format String Vulnerability
```c
printf(buffer);
```
The user input is passed directly as the format string to `printf()`, allowing us to:
- Leak memory contents using format specifiers like `%p`, `%x`
- Read arbitrary memory locations using positional parameters like `%n$p`

#### 2. Arbitrary Code Execution
```c
void (*foo)(void) = (void (*)())val;
foo();
```
Same as PIE TIME - allows jumping to any address provided by the user.

## Reverse Engineering Analysis

Using GDB, I disassembled the key functions to understand the memory layout and security mechanisms:

### main Function
![Main function disassembly](https://github.com/user-attachments/assets/22523697-183c-4d06-9e30-a3c464ea9119)

### win Function
![Win function disassembly](https://github.com/user-attachments/assets/dadbca91-5ac2-44a9-9a5b-f67683269734)

### call_functions Function
![Call_functions disassembly](https://github.com/user-attachments/assets/f5ba31f6-a2be-41a8-bce2-3b0fdf102ae1)

## Stack Canary Protection Analysis in call_function()

The disassembly reveals an important security mechanism - **Stack Smashing Protector (Stack Canary)**:

### Canary Setup (Function Prologue)
```assembly
0x00000000000012d3 <+12>:    mov    rax,QWORD PTR fs:0x28
0x00000000000012dc <+21>:    mov    QWORD PTR [rbp-0x8],rax
```

### Canary Check (Function Epilogue)
```assembly
0x0000000000001354 <+141>:   mov    rax,QWORD PTR [rbp-0x8]
0x0000000000001358 <+145>:   xor    rax,QWORD PTR fs:0x28
0x0000000000001361 <+154>:   je     0x1368 <call_functions+161>
0x0000000000001363 <+156>:   call   0x1130 <__stack_chk_fail@plt>
```

### How Stack Canary Works

The Stack Smashing Protector is a security mechanism that detects buffer overflows:

1. **Canary Placement**: A random secret value is placed on the stack between local variables and the return address
2. **Stack Layout** (grows downward):
   ```
   Higher Addresses
   ┌─────────────────────┐
   │   Return Address    │ ← Critical control data
   │   Saved RBP         │ ← Critical control data  
   │   Stack Canary      │ ← Protection barrier ([rbp-0x8])
   │   Local Variables   │ ← buffer[64], val, etc.
   └─────────────────────┘
   Lower Addresses
   ```

3. **Overflow Detection**: If a buffer overflow corrupts the canary, the program detects this during the epilogue check and calls `__stack_chk_fail` to terminate safely.

## Exploitation Strategy

Since no address is directly leaked, I need to use the format string vulnerability to leak memory addresses and calculate the location of the `win()` function.

### Step 1: Calculate Function Offsets

Using GDB runtime analysis:
- `main()` starts at: `0x0000555555555400`
- `win()` starts at: `0x000055555555536a` 
- Offset: `main - win = 150 bytes` (constant due to PIE)

### Step 2: Find Memory Leak via Format String

I tested various format string specifiers (%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p and %1$p,%2$p,%3$p ....) to find useful memory addresses:

![Format string testing](https://github.com/user-attachments/assets/769e7668-8973-491c-9283-632c9f088ef7)

The format specifier `%19$p` revealed an interesting address: `0x555555555441`

### Step 3: Address Calculation

Looking at the main function disassembly, I determined that:
- `0x555555555441` corresponds to an instruction within `main()`
- This address is `0x41` bytes from the start of `main()`
- Therefore: `main_address = leaked_address - 0x41`

### Step 4: Calculate Win Address

With the main address known:
```
win_address = main_address - offset
win_address = (leaked_address - 0x41) - 150
```

## Exploit Execution

### The Complete Attack Plan:
1. Use format string `%19$p` to leak a memory address within `main()`
2. Calculate the actual `main()` address by subtracting `0x41`
3. Calculate the `win()` address by subtracting the offset of `150`
4. Provide the calculated `win()` address to execute the target function

### Final Exploit:

![Successful exploitation](https://github.com/user-attachments/assets/1e706b84-3d2e-40bc-b2cd-5f63e08c4365)

**Success!** The exploit worked and revealed the flag.

## Key Techniques Demonstrated

### 1. Format String Information Disclosure
- Used `%n$p` syntax to read specific stack positions
- Leveraged the vulnerability to bypass ASLR/PIE protections

### 2. Address Calculation with PIE
- Utilized constant offsets between functions despite randomized base addresses
- Performed runtime address arithmetic to locate target functions

### 3. Multi-Stage Exploitation
- Combined information disclosure with code execution vulnerabilities
- Chained vulnerabilities to achieve the final objective

### 4. Stack Canary Bypass
- Although stack canaries were present, the exploitation path avoided triggering them by not overflowing buffers

## Security Implications

This challenge demonstrates several important security concepts:

1. **Format String Vulnerabilities**: Can lead to information disclosure and potential code execution
2. **Defense in Depth**: Multiple protections (PIE + Stack Canaries) require more sophisticated attacks
3. **Information Leaks**: Even small information disclosures can be leveraged to defeat modern protections
4. **Vulnerability Chaining**: Combining multiple vulnerabilities often leads to full compromise

## Tools Used
- **GDB**: For runtime debugging and disassembly analysis
- **Format String Testing**: To identify useful memory leaks
- **Manual Address Calculation**: For PIE bypass techniques

## Mitigation Recommendations

- Use safe format string functions (avoid `printf(user_input)`)
- Implement proper input validation and bounds checking
- Consider additional mitigations like Control Flow Integrity (CFI)
- Regular security audits and static analysis tools
